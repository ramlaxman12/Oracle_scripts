<hj-Treepad version 0.9>
<node>
common_queries
0
<end node> 5P9i0s8y19Z
<node>
LOCKS
1
                          DB-Locks
                           ========

===========================
LOCK Query
===========================
SELECT sn.username, m.sid, m.type,
   DECODE(m.lmode, 0, 'None'
                 , 1, 'Null'
                 , 2, 'Row Share'
                 , 3, 'Row Excl.'
                 , 4, 'Share'
                 , 5, 'S/Row Excl.'
                 , 6, 'Exclusive'
                 , lmode, ltrim(to_char(lmode,'990'))) lmode,
   DECODE(m.request, 0, 'None'
                 , 1, 'Null'
                 , 2, 'Row Share'
                 , 3, 'Row Excl.'
                 , 4, 'Share'
                 , 5, 'S/Row Excl.'
                 , 6, 'Exclusive'
                 , request, ltrim(to_char(request,'990'))) request,
         obj1.object_name objname, obj2.object_name objname
FROM v$session sn, V$lock m, dba_objects obj1, dba_objects obj2
WHERE sn.sid = m.sid
AND m.id1 = obj1.object_id (+)
AND m.id2 = obj2.object_id (+)
     AND lmode != 4
ORDER BY id1,id2, m.request
/

select /*+ ordered use_nl(lob pn ses) */
       decode(lob.kglobtyp, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
                      7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY',
                      19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',
                      22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30, 'JAVA RESOURCE',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      34, 'TABLE SUBPARTITION', 35, 'INDEX SUBPARTITION',
                      40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',
                      42, 'MATERIALIZED VIEW',
                      43, 'DIMENSION',
                      44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',
                      48, 'CONSUMER GROUP',
                      51, 'SUBSCRIPTION', 52, 'LOCATION',
                      55, 'XML SCHEMA', 56, 'JAVA DATA',
                      57, 'SECURITY PROFILE', 59, 'RULE',
                      62, 'EVALUATION CONTEXT',
                     'UNDEFINED') object_type,
       lob.kglnaobj object_name,
       pn.kglpnmod lock_mode_held,
       pn.kglpnreq lock_mode_requested,
       ses.sid,
       ses.serial#,
       ses.username
  from v$session_wait vsw,
       x$kglob lob,
       x$kglpn pn,
       v$session ses
 where vsw.event = 'library cache lock'
   and vsw.p1raw = lob.kglhdadr
   and lob.kglhdadr = pn.kglpnhdl
   and pn.kglpnmod != 0
   and pn.kglpnuse = ses.saddr
order by pn.kglpnmod desc, pn.kglpnreq desc
/
=====================================================
To generate the  blocking locks report
=====================================================
SELECT *
  FROM (  SELECT a.sql_id,
                 a.sample_time,
                 COUNT (*)
                 OVER (PARTITION BY a.blocking_session, a.user_id, a.program)
                    cpt,
                 ROW_NUMBER ()
                 OVER (PARTITION BY a.blocking_session, a.user_id, a.program
                       ORDER BY blocking_session, a.user_id, a.program)
                    rn,
                 a.blocking_session,
                 a.user_id,
                 a.program,
                 s.sql_text
            FROM sys.WRH$_ACTIVE_SESSION_HISTORY a, sys.wrh$_sqltext s
           WHERE     a.sql_id = s.sql_id
                 AND blocking_session_serial# <> 0
                 AND a.user_id <> 0
                 AND a.sample_time > SYSDATE - 1
        ORDER BY a.sample_time)
 WHERE rn = 1
/

SELECT  distinct a.sql_id ,a.inst_id,a.blocking_session,a.blocking_session_serial#,a.user_id,s.sql_text,a.module
FROM  GV$ACTIVE_SESSION_HISTORY a  ,gv$sql s
where a.sql_id=s.sql_id
and blocking_session is not null
and a.user_id <> 0 -  exclude SYS user 
and a.sample_time > sysdate - 7


select * from (
SELECT a.sql_id ,
COUNT(*) OVER (PARTITION BY a.blocking_session,a.user_id ,a.program) cpt,
ROW_NUMBER() OVER (PARTITION BY a.blocking_session,a.user_id ,a.program
order by blocking_session,a.user_id ,a.program ) rn,
a.blocking_session,a.user_id ,a.program, s.sql_text
FROM sys.WRH$_ACTIVE_SESSION_HISTORY a ,sys.wrh$_sqltext s
where a.sql_id=s.sql_id
and blocking_session_serial# <> 0
and a.user_id <> 0
and a.sample_time > sysdate - 10
) where rn = 1

======================================================

Locked Objects Detail with SID and process info(EVENTS)
===============================================

select spid from v$process a,v$session b where a.addr=b.paddr and b.sid in (1053);
select sid from v$session a,v$process b where a.paddr=b.addr and b.spid in (15805);

set pages 999
set lines 200
col objectname for a30
col program for a40
col process for a10
col EVENT for a30
col mode for a10
col LOGONTIME for a20
select substr(s
.sid,1,5) SID, substr(d
.object_name,1,30) OBJECTNAME,substr(w
.event,1,19) "EVENT",substr(o
.locked_mode,1,3) "MODE", substr(o
.process,1,7) "PROCESS",substr(nvl(s
.program,machine),1,13) "PROGRAM", TO_CHAR(s
.LOGON_TIME,'ddmon hh:mi:ss') LOGONTIME
from v$locked_object o,  v$session_wait w, 
dba_objects d, v$session s
where s
.sid = o
.session_id AND d
.object_id = o
.object_id AND w
.sid = s
.sid  ;

============================

HOLDER AND WAITER
============================

select 
decode(request,0,'Holder',
'Waiter')"STATE",
substr(v$session_wait
.sid,1,8)"SID",
substr(type,1,4)"TYPE",
substr(lmode,1,2) "L",
substr(id1,1,10)"id1",
substr(id2,1,10)"id2",
substr(event,1,30)"EVENT",
wait_time "WAIT"
from v$lock,v$session_wait 
where (id1, id2, type) in
(select id1, id2, type 
from v$lock where request>0)
and v$session_wait
.sid = v$lock
.sid
order by id1,1;
======================
For RAC Holder & Waiter
======================
SELECT DECODE(request,0,'Holder: ','Waiter: ')||sid sess,inst_id
        id1, id2, lmode, request, type
   FROM GV$LOCK
  WHERE (id1, id2, type) IN
            (SELECT id1, id2, type FROM GV$LOCK WHERE request>0)
  ORDER BY id1, request;

==================================================================
Finding Library cache locks
==================================================================
first who is waiting for Library Cache Pins/Locks:
==================================================================
COL event FORMAT a20 TRUNC
 tti "Users Waiting for Library Cache Pins"
 SELECT sid, event, p1raw, seconds_in_wait, wait_time
  FROM sys.v_$session_wait
  WHERE event = 'library cache pin'
  AND state = 'WAITING'
  /
==================================================================
P1raw is the "Handle Address" of the object that is blocking. 
==================================================================
Execute the following query to get the object's owner and name:
==================================================================

 tti "Object that is Blocking"
COL owner format a8
 COL object format a70
 SELECT kglnaown AS owner, kglnaobj as Object
  FROM sys.x$kglob
  WHERE kglhdadr='&P1RAW'
  /

==================================================================
Identify the users that are waiting/ blocking:
==================================================================
 tti "Blocking/Waiting Users"
 col SID_SERIAL format a12
 SELECT s.sid||','||s.serial# SID_SERIAL, kglpnmod "Mode Held", kglpnreq "Request"
  FROM sys.x$kglpn p, sys.v_$session s
  WHERE p.kglpnuse = s.saddr
  AND kglpnhdl   = '&P1RAW'
  /



==================================================================
select s.sid,p.serial# from v$session s,v$process p 
where s.paddr=p.addr 
and s.sid=34
==================================================================
To get OS id
==================================================================
select spid,process
from v$session,v$process
where addr=paddr
and sid=94;


select sid,serial#,status,program from v$session where sid=477;
==================================================================
1 Check for orphaned process

select spid  from v$process where addr not in (select paddr from v$session) and spid is not null;

==================================================================

SELECT o.object_name,
       v.session_id sid,
       v.oracle_username,
       decode(l.type,'TM', 'DML enqueue (TM)', 'TX', 'Transaction enqueue (TX)', 'UL', 'User supplied (UL)', l.type),
       decode(l.lmode,0,'None',1,'Null',2,'Row Share',3,'Row Excl.',4,'Share',5,'S/Row Excl.',6,'Exclusive',to_char(l.lmode,'990')) holding,
       decode(l.request,0,'None',1,'Null',2,'Row Share',3,'Row Excl.',4,'Share',5,'S/Row Excl.',6,'Exclusive',to_char(l.request,'990')) wanting,
       l.block,
       s.terminal,
       s.machine
FROM sys.v_$locked_object v,
     sys.v_$lock l,
     sys.dba_objects o,
     sys.v_$session s
WHERE l.sid = v.session_id
AND   s.sid = v.session_id
AND   v.object_id = o.object_id;

==================================================================
Session Details
==================================================================

select sid,program,username,osuser,machine,status,to_char(logon_time,'dd/mon/yyyy hh24:mi:ss') from v$session where username is not null
and status='INACTIVE';

==================================================================
To find the controlfile Enque
==================================================================

SELECT s.sid, username AS "User", program, module, action, logon_time "Logon", l.* 
FROM v$session s, v$enqueue_lock l
WHERE l.sid = s.sid and l.type = 'CF' AND l.id1 = 0 and l.id2 = 2;



FOR RAC
====================================
-- Locked Objects
col owner on for a18
set lines 200
set pages 999
col object_name on for a30
col ORACLE_USERNAME on for a18
SELECT o.owner, o.object_name, o.object_type, o.last_ddl_time, 
o.status, l.session_id,l.inst_id, l.oracle_username, l.locked_mode
FROM dba_objects o, gv$locked_object l
WHERE o.object_id = l.object_id order by l.inst_id,l.session_id;


select s1.username || '( INSTANCE ' || s1.inst_id ||' )'||'@' || s1.machine || 
' ( SID=' || s1.sid || ' )  is blocking ' || s2.username || ' ( INSTANCE ' || s2.inst_id || ' )'|| '@' || s2.machine || 
' ( SID=' || s2.sid || ' ) '  AS blocking_status
from gv$lock l1, gv$session s1, gV$lock l2, gv$session s2
where s1.sid=l1.sid and s2.sid=l2.sid
and l1.BLOCK=1 and l2.request > 0
and l1.id1 = l2.id1
and l2.id2 = l2.id2 
order by  s1.inst_id;

============================
DFS Lock Handle
============================

SELECT chr(to_char(bitand(p1,-16777216))/16777215)||
	chr(to_char(bitand(p1, 16711680))/65535) "Lock",
	to_char( bitand(p1, 65535) )    "Mode"
FROM v$session_wait
WHERE event = 'DFS lock handle';




sid's of blockers:
===============

select sid from v$lock where block=1;


select distinct event from v$session_wait;

sessions using the OBJECT
======================

select sid from v$access
where object like '%PS_C_CUBE_INITIALIZE%';

Program creating the block:
======================
select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid in (select sid from v$access
where object in
('PSYPSPCMPROG'));


SELECT segment_owner, segment_name
  FROM DBA_EXTENTS
 WHERE file_id = <&p1>
   AND <&p2> BETWEEN block_id AND block_id + blocks - 1;


Lock on a Particular Object:
============================
select b.owner,rpad(object_name,25,' ') ObjName,d.sid,
substr(nvl(d.program,
d.machine),1,18) Program,to_char(d
.logon_time,'DD::HH:MI:SS') LogTime , 
substr(spid,1,8) SPID,substr(d
.process,1,8) PROCESS,
 substr(a
.locked_mode,1,2) "Mode",
substr(e.event,1,15) EVENT from
v$locked_object a,dba_objects b,
v$process c,v$session d, 
v$session_wait e
where d
.sid= e
.sid and a
.object_id = b
.object_id and c
.addr = d
.paddr and d
.sid = a
.session_id and 
object_name like '%PSYPSPCMPROG%'
order by to_char(d
.logon_time,'DD::HH:MI:SS') ;

New:
--------
select rpad(object_name,25,' ') ObjName,d
.sid,
substr(nvl(d
.program,
d
.machine),1,18) Program,to_char(d
.logon_time,'DD::HH:MI:SS') LogTime , 
substr(spid,1,8) SPID,substr(d
.process,1,8) PROCESS,
substr(a
.locked_mode,1,2) "Mode",
substr(e
.event,1,15) EVENT 
from
v$locked_object a,dba_objects b,
v$process c,v$session d, 
v$session_wait e
where d
.sid= e
.sid and a
.object_id = b
.object_id and c
.addr = d
.paddr and d
.sid = a
.session_id and 
object_name like '%BP_EDC_SCOAT_ALL%'
order by to_char(d
.logon_time,'DD::HH:MI:SS') ;




For Version7:
=============
select distinct 
spid,process,
substr(v$session
.program,1,30)"PRGM",
substr(object,1,15)
"OBJECT"
from v$session,v$process,
v$access
where paddr=addr 
and v$session
.sid = v$access
.sid and type 
<> 'BACKGROUND'
and v$session
.sid in (select 
sid from v$lock
where lmode=6);



IN CASE OF ENQUEUES
====================

select sid from v$lock where block=1;
== gives the holding sessions

select  *  from dba_waiters;

Detect Enqueue Programs
======================

select s
.sid,nvl(program,machine),process,object 
from v$session s ,v$access a
where a
.sid=s
.sid and s
.sid in (select 
sid from 
v$session_wait
where event like '%enque%');

select 
sid,nvl(program,machine),process
from v$session 
where sid in (select 
sid from 
v$session_wait
where event like '%enque%');

select 
sid,nvl(program,machine),process
from v$session 
where sid in (select 
sid from 
v$session_wait
where event like '%db_file_scattered%');

select distinct sid 
from v$access 
where object in ('CDMST')

<end node> 5P9i0s8y19Z
<node>
example
2
callers object: ca380tb

select rpad(object_name,10,' ') ObjName,
substr(nvl(d
.program,d
.machine),1,18) Program,to_char(d
.logon_time,'DD::HH:MI:SS') LogTime , 
substr(spid,1,8) SPID,substr(d
.process,1,8) PROCESS,
 substr(a
.locked_mode,1,2) "Mode",
substr(event,1,15) EVENT from
v$locked_object a,dba_objects b,
v$process c,v$session d, 
v$session_wait e
where d
.sid= e
.sid and a
.object_id = b
.object_id and c
.addr = d
.paddr and d
.sid = a
.session_id;


output 1:

CA380TB    phys-yamuna        28::04:16:46 28378    28279    3  SQL*Net message 

CA380TB    phys-yamuna        28::04:41:26 13667    13626    3  SQL*Net message

CA380TB    phys-yamuna        28::04:36:16 29203    29162    3  SQL*Net message 

CA380TB    phys-yamuna        28::04:24:58 26583    26529    3  SQL*Net message

CA380TB    phys-yamuna        28::03:28:44 22204    22152    3  SQL*Net message




select sid from v$lock where block=1;


holders
----------------------------
                         675
                         596




select  *  from dba_waiters;

output 2:

WAITING_SESSION              HOLDING_SESSION              LOCK_TYPE                  MODE_
HELD                                MODE_REQUESTED                           LOCK_ID1
                LOCK_ID2
---------------------------- ---------------------------- -------------------------- ----
--------------- ----------------------------
--------------- ----------------------------
                         595                          596 Transaction                Exclu
sive                                Share
        2293781                        89106
                         396                          596 Transaction                Exclu
sive                                Share
        2293781                        89106
                          26                          596 Transaction                Exclu
sive                                Share
        2293781                        89106
                         336                          675 Transaction                Exclu
sive                                Exclusive
        2031648                        97712
                         272                          675 Transaction                Exclu
sive                                Exclusive
        2031648                        97712
                         220                          675 Transaction                Exclu
sive                                Exclusive
        2031648                        97712

6 row(s) selected


use below 2 queries and

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid in (595,396,26,336,272,220);  -- waiters sid list from output 2:.

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid in (498,526);  -- holders sid list from output 2:.

eg:
SPID      PROCESS   SID                          PROGRAM
--------- --------- ---------------------------- ------------------------------
29867     29858                              675 cc061ct@phys-yamuna (TNS V1-V3
14542     14533                              596 gr205cm@phys-yamuna (TNS V1-V3





if output of these doesn't corelate to the sid or spid of (output 1) then it means that the holders and waiters are for 

different objects and not for the objects of callers interest. 
in that cae

PG THE PROCESS GOT from (output 1) find the program name from 

it and tell the caller that lock is caused by those programs and started on the time specified and ask them if those programs 

can be killed. If so kill them.

<end node> 5P9i0s8y19Z
<node>
LONGOPS
1
                              		     LongOps
     		                                    ======= 
Long Operations Messages
========================
Index Fast Full Scan: DE Index Fast Full Scan:DELOASIS.GR020MB:3950 out of 3950 Blocks done
Table Scan          : DELOASIS.CA010MB: 5983 out of 17366 Blocks done
Hash Join           : 2700 out of 38565 Blocks done
Sort Output         : 2038 out of 7471 Blocks done
SQL Execution:      : 1811 out of 15093 units done
Index Range Scan

Assess Top 10 Database Wait Events
==================================

select event, total_waits,
round(time_waited/100) "TIME(s)",
average_wait*10 "AVG(ms)",
TO_CHAR(SYSDATE, 'DD-MON-YYYY HH:MI:SS') time
from v$system_event where time_waited > 100 and
event not in ('rdbms ipc message','pmon timer','control file heartbeat','smon timer')
order by time_waited; 

Currently running query
===================
col MESSAGE for a70
Select s.username, l.sid, l.message, l.time_remaining
from v$session_longops l, v$session s
where l.sid = s.sid
and l.time_remaining > 0

SELECT SID
,SERIAL#
,USERNAME
,OPNAME
,TO_CHAR(START_TIME,'DD-MON-YYYY HH24 MI SS') STARTED
,SOFAR/TOTALWORK*100||'%' PCT_COMPLETE
,ELAPSED_SECONDS/60 MINUTES
,TOTALWORK
,UNITS
,TIME_REMAINING
FROM V$SESSION_LONGOPS
WHERE time_remaining>0
ORDER BY ELAPSED_SECONDS DESC;
==================================================================================================================================================================================
Long running query More than 1hr
==================================================================================================================================================================================
col sid format 9999
col pid format 999999
col serial# format 999999
col username format a10
col osuser format a10
col program format a25
col host format a20
col run_hr format 9999
col terminal format a20
col process format a20
col client_info format a45
col sql_text format a1000
col usr_flag format a2
SELECT chr(12),a.instance_name,ss.SID,ss.serial#,p.spid pid,ss.status,ss.username,ss.osuser,ROUND(ss.last_call_et/60/60,0) run_hr,ss.logon_time,ss.machine host,ss.terminal,ss.program,ss.process,ss.client_info,s.sql_text FROM v$instance a,v$session ss,v$sql s,v$process p WHERE ss.SQL_address=s.address AND p.addr=ss.paddr and ss.username IS NOT NULL AND s.child_number <1 AND USERENV('SESSIONID') <> ss.audsid AND  ROUND(ss.last_call_et/60/60) >= 1 AND ss.status = 'ACTIVE' ORDER BY ss.username, s.buffer_gets DESC;
==================================================================================================================================================================================
LONG OPS wrt IO
-------------------------------
select substr(sl
.sid,1,5) "SID",lpad(pr
.spid,6,' ') SPID,lpad(ss
.process,6,' ') PROCESS,substr(nvl(ss
.program,ss
.machine),1,15) PRGM,
substr(object_name,1,8) "ObjName",
substr(round(sw
.seconds_in_wait/60,0),1,2) "WMin",
substr(event,1,13) "Event",
lpad(round(sofar*8192/
(1024*1024)),7,' ') "Sofar",
lpad(round(totalwork*8192/
(1024*1024)),7,' ') "Tot_Wrk"
from v$session_longops sl, 
v$session_wait sw, v$process pr, 
v$session ss, dba_objects do where sl
.sid = sw
.sid and pr
.addr = ss
.paddr and ss
.sid = sw
.sid and sl  
.sid = ss
.sid and do
.object_id = sl
.objid and
totalwork <> sofar and 
round(totalwork*8192/(1024*1024)) >= 10; 

To see the Long Operations
==========================
SELECT MESSAGE FROM V$SESSION_LONGOPS
WHERE TIME_REMAINING > 252;
====================================================
Program,spid,process running for more than four hour
====================================================

select substr(s
.sid,1,8),substr(s
.process,1,8)PROCESS,substr(p
.spid,1,8)SPID,substr(s
.program,1,30)PROGRAM,substr(round(sw
.seconds_in_wait/3600,2),1,5) HRS_WAIT
from v$session s,v$session_wait sw,
V$process p where s
.paddr=p
.addr and s
.sid=sw
.sid and sw
.state='WAITING' 
and round(sw 
.seconds_in_wait/3600,2) > 24
order by substr(round(sw
.seconds_in_wait/3600,2),1,5)  desc;

================================================================================================
To check status of long operation
===========================

SELECT sid, serial#, context, sofar, totalwork,round(sofar/totalwork*100,2) "% Complete%" FROM v$session_longops where sid=425;

COL MINUTES        FORMAT 999,990.99
COL HOURS          FORMAT 999,990.99
COL MESSAGE        FORMAT A22
COL OPNAME         FORMAT A30        HEA "O P E R A T I O N"
COL PCT_COMPLETE   FORMAT A04        HEA "PCT |DONE" TRUNC JUST RIGHT
COL SERIAL#        FORMAT 99999
set lines 200 pages 999
COL SID            FORMAT 999999999
COL STARTED        FORMAT A20        HEA "S T A R T  T I M E"
COL TARGET         FORMAT A16
COL TARGET_DESC    FORMAT A16
COL TIME_REMAINING FORMAT 99,999,999
COL UNITS          FORMAT A10
COL USERNAME       FORMAT A12
SET ECHO OFF
SET ECHO ON
SELECT SID
      ,SERIAL#
      ,USERNAME
      ,OPNAME
      ,TO_CHAR(START_TIME,'DD-MON-YYYY HH24 MI SS') STARTED
      ,SOFAR/TOTALWORK*100||'%'                     PCT_COMPLETE
      ,ELAPSED_SECONDS/60                           MINUTES
      ,TOTALWORK
      ,UNITS
      ,TIME_REMAINING
   FROM V$SESSION_LONGOPS
   where USERNAME != 'SYS'
and time_remaining>0
   ORDER BY ELAPSED_SECONDS DESC;

================================================================================================


select sid,message from v$session_longops
where sid = 252 order by  start_time;


================================================================================================

<end node> 5P9i0s8y19Z
<node>
MORNING REPORT
1
                                                                                      CRITERIA FOR MORNING REPORT
                                                                                      ==============================

CRITERIA TO BE FOLLOWED FOR TABLESPACE EXTENT ALLOCATION
============================================================

If SUM(NEXT_EXTENT/1024/1024)*3 > FREE_IN_MB, then space must be incr


TO FIND THE TOTAL FREE SPACE (FREE CHUNCKS) OFF ALL TABLESPACES IN A DATABASE
===============================================================================

select substr(tablespace_name,1,25)
"TABLESPACE NAME",
ceil(sum(bytes/1024/1024))
"TOTAL FREE SPACE (CHUNKS)" from dba_free_space
group by substr(tablespace_name,1,25)
order by ceil(sum(bytes/1024/1024));

OR

select tablespace,
ceil(free_in_mb) "TOTAL FREE SPACE (CHUNCKS)"
from pct1$
order by ceil(free_in_mb);


TO FIND THE TOTOAL FREE SPACE (FREE CHUNCKS) OF ALL TABLESPACES WHOSE FREE CHUNKS ARE LESS THAN 200
=========================================================================================================

select dname
.name "DB-NAME",a
.tabsp "TABLE-SPACE",a
.max "MAX-AVBL" from 
dual, (select name from v$database )
dname,
(select substr(tablespace_name,1,25) 
tabsp,
ceil(sum(bytes/1024/1024)) 
max from dba_free_space where 
tablespace_name
not in ('ROLLBACK','TEMP')
group by tablespace_name) a where a
.max <= 200 ;

OR

select substr(tablespace,1,24) "TABLESPACE",
ceil(free_in_mb) "TOTAL FREE SPACE (CHUNCKS)"
from pct1$
where free_in_mb <= 200
order by ceil(free_in_mb);

CRITERIAS TO BE FOLLOWED FOR INDIVIDUAL OBJECT  
===============================================

CRITERIA NO:1
=============

If the total number of extents for a single object reaches beyond 300 , then the object must be re-organised.
(ie) if the max_extents goes beyond 300 for a single object, it must be dropped and recreated to increase the performance.

SELECT SUM(

CRITERIA NO:2
=============

TO DISPLAY THE OBJECTS WHICH DO NOT HAVE THE SPACE TO EXTEND 
=================================================================
This query displays the object which do not have the space to extend its NEXT_EXTENT parameter.

select substr(owner,1,10) Owner,
substr(a
.tablespace_name,1,14) Tablespace,
substr(segment_name,1,20) Object,
substr(segment_type,1,8) Type,
substr(next_extent/1024/1024,1,8) Next_extent,
substr(max_in_mb,1,8) Max_in_mb from
dba_segments a,pct$ b
where a
.tablespace_name=b
.tablespace
and a
.next_extent/1024/1024 > b
.MAX_IN_MB;

TO DISPLAY THE OBJECTS HAVING EXTENTS REACHING MAX EXTENTS
=================================================================
This query is applicable to objects, which has been created with the parameter MAX_EXTENTS.
This query lists the objects for the following criteria :  
If the difference between (total number of free/max extents) to the (total number of allocated extents)  is less than 10 extents.

select substr(owner,1,10) Owner,
substr(tablespace_name,1,14) Tablespace,
substr(segment_name,1,20) Object,
substr(segment_type,1,8) Type,
substr(extents,1,4) ext,
substr(max_extents,1,4) mext from
sys
.dba_segments
where max_extents - extents < 10 and
segment_type != 'CACHE' ;

OR

select substr(owner,1,10) Owner,
substr(tablespace_name,1,14) Tablespace,
substr(segment_name,1,20) Object,
substr(segment_type,1,8) Type,
substr(extents,1,4) ext,
substr(max_extents,1,4) mext from
sys.dba_segments
where max_extents - extents < 10 and
segment_type != 'CACHE'  and
(segment_name not like '%SYS%')
and (segment_name not like '%ORG%')
and (segment_name not like '%OLD%' );

CRITICAL TABLESPACE REPORT
============================

ROLLBACK SEGMENT REPORT
==========================

CRITERIA NO:1
=============
ROLLBACK SEGMENT HAVING MORE THAN 70% STATUS
=================================================

CRITERIA NO:2
=============
OLD TRANSACTIONS HELD IN ROLLBACK SEGMENT
=============================================

PENDING TRANSACTIONS REPORT
==============================

TO CHECK THE PENDING TRNASACTION
===================================

DBUPTIME REPORT
=================
TO CHECK THE OPEN STATUS OF DATABASE
=======================================

DATAFILE COUNT REPORT
=======================
This query reports the difference between the parameter MAX_FILES and the number of datafiles in the database

PROCESSES COUNT REPORT
==========================
This query reports the 

<end node> 5P9i0s8y19Z
<node>
TABLESPACE_MONITORING
1
======================================================================================================
To chek the filename and size
======================================================================================================
set pages 999
set lines 200
col file_name for a60
select file_name,bytes/1024/1024 from dba_data_files where tablespace_name in ('LCDBDMS_DATA')


select sum(bytes)/1024/1024/1024 from dba_data_files where tablespace_name='SECCOMPAS_DATA1';
select sum(bytes)/1024/1024 from dba_free_space where tablespace_name='ASDS_DATA';

select tablespace_name from dba_segments where segment_name='PNA_NC_NTPA_PRICE_FEED';

======================================================================================================
To chek the Tablespace Utilization
======================================================================================================

set lines 1000
set pages 100
col name     format A30         head "Tablespace Name"
col pct_used format 999.9       head "Pct|Used"
col Kbytes   format 999,999,999,999 head "KBytes"
col used     format 999,999,999,999 head "Used"
col free     format 999,999,999 head "Free"
col max_free format 999,999,999 head "Max size|free chunk"
break   on report
compute sum of kbytes on report
compute sum of free on report
compute sum of used on report
 
select   nvl(FULL.tablespace_name,nvl(FREE.tablespace_name,'UNKOWN')) Name
        ,kbytes_used                    Kbytes
        ,kbytes_used-nvl(kbytes_free,0) Used
        ,nvl(kbytes_free,0)             Free
        ,((kbytes_used-nvl(kbytes_free,0)) / kbytes_used)*100 Pct_used
        ,nvl(max_free,0)                Max_free
from
     ( select  sum(bytes)/1024    Kbytes_free
              ,max(bytes)/1024    max_free
              ,tablespace_name
       from    sys.DBA_FREE_SPACE
       group by tablespace_name ) FREE,
     ( select  sum(bytes)/1024    Kbytes_used
              ,tablespace_name
       from    sys.DBA_DATA_FILES
       group by tablespace_name ) FULL
where  FREE.tablespace_name (+) = FULL.tablespace_name
       -- and full.tablespace_name like '%TRE%'
order by  name
/


set lines 200 pages 999
 column dummy noprint
 column  pct_used format 999.9       heading "%|Used"
 column  name    format a40      heading "Tablespace Name"
 column  MB   format 999,999,999    heading "KBytes"
 column  used    format 999,999,999   heading "Used"
 column  free    format 999,999,999  heading "Free"
 column  largest    format 999,999,999  heading "Largest"
 column  max_size format 999,999,999 heading "MaxPoss|MB"
 column  pct_max_used format 9999999.999       heading "%|Max|Used"
 break   on report
 compute sum of MB on report
 compute sum of free on report
 compute sum of used on report

 select (select decode(extent_management,'LOCAL','',' ') ||
                 decode(segment_space_management,'AUTO',' ',' ')
                from dba_tablespaces where tablespace_name = b.tablespace_name) || nvl(b.tablespace_name,
              nvl(a.tablespace_name,'UNKOWN')) name,
             MB_alloc Allocated_GB,
             MB_alloc-nvl(MB_free,0) Used_GB,
             nvl(MB_free,0) Free_GB,
             ((MB_alloc-nvl(MB_free,0))/MB_alloc)*100 pct_used
     from ( select sum(bytes)/1024/1024/1024 MB_free,
                            max(bytes)/1024/1024/1024 largest,
                            tablespace_name
             from  sys.dba_free_space
             group by tablespace_name ) a,
       ( select sum(bytes)/1024/1024/1024 MB_alloc,
                            sum(maxbytes)/1024/1024/1024 MB_max,
                            tablespace_name
             from sys.dba_data_files
             group by tablespace_name
             union all
      select sum(bytes)/1024/1024/1024 MB_alloc,
                           sum(maxbytes)/1024/1024/1024 MB_max,
                           tablespace_name
            from sys.dba_temp_files
           group by tablespace_name )b
 where a.tablespace_name (+) = b.tablespace_name
 order by 1;

======================================================================================================
For 1 Tablespace
======================================================================================================
set lines 200 pages 999
 column dummy noprint
 column  pct_used format 999.9       heading "Used%"
 column  name    format a40      heading "Tablespace Name"
 column  MB   format 999,999,999    heading "KBytes"
 column  used    format 999,999,999   heading "Used"
 column  free    format 999,999,999  heading "Free"
 column  largest    format 999,999,999  heading "Largest"
 column  max_size format 999,999,999 heading "MaxPoss|MB"
 column  pct_max_used format 9999999.999       heading "%|Max|Used"
 break   on report
 compute sum of MB on report
 compute sum of free on report
 compute sum of used on report

 select (select decode(extent_management,'LOCAL','',' ') ||
                 decode(segment_space_management,'AUTO',' ',' ')
                from dba_tablespaces where tablespace_name = b.tablespace_name) || nvl(b.tablespace_name,
              nvl(a.tablespace_name,'UNKOWN')) name,
             MB_alloc Allocated_MB,
             MB_alloc-nvl(MB_free,0) Used_MB,
             nvl(MB_free,0) Rree_MB,
             ((MB_alloc-nvl(MB_free,0))/MB_alloc)*100 pct_used
     from ( select sum(bytes)/1024/1024 MB_free,
                            max(bytes)/1024/1024 largest,
                            tablespace_name
             from  sys.dba_free_space
             group by tablespace_name ) a,
       ( select sum(bytes)/1024/1024 MB_alloc,
                            sum(maxbytes)/1024/1024 MB_max,
                            tablespace_name
             from sys.dba_data_files
             group by tablespace_name
             union all
      select sum(bytes)/1024/1024 MB_alloc,
                           sum(maxbytes)/1024/1024 MB_max,
                           tablespace_name
            from sys.dba_temp_files
           group by tablespace_name )b
 where a.tablespace_name = 'ODSUD'
 and a.tablespace_name  (+) = b.tablespace_name
 order by 1;
======================================================================================================
Tablespace Usages on daily basis
======================================================================================================

select a.name ,sum(b.TABLESPACE_USEDSIZE)/1024/1024 from DBA_HIST_TBSPC_SPACE_USAGE b,v$tablespace a where
substr(RTIME,1,10)='07/28/2009' and a.ts#=b.TABLESPACE_ID group by  a.name
/
======================================================================================================
To get the datafile resize
======================================================================================================

column cmd format a75 word_wrapped

select 'alter database datafile ''' || file_name || ''' resize ' ||
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 )  || 'm;' cmd
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+)
  and ceil( blocks*&&blksize/1024/1024) -
      ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) > 0
/ 



select tablespace_name,sum(bytes/1024/1024),autoextensible from
dba_data_files where tablespace_name='PSINDEX'
group by tablespace_name,autoextensible




SELECT ROUND(SUM(bytes/1024/1024/1024)) "USED_BYTES_IN_GB" ,ROUND(SUM(CASE when maxbytes/1024/1024/1024 < bytes/1024/1024/1024  then bytes/1024/1024/1024 else maxbytes/1024/1024/1024 end )) "MAX_BYTES_IN_GB" , 
(ROUND(SUM(CASE when maxbytes/1024/1024/1024 < bytes/1024/1024/1024  then bytes/1024/1024/1024 else maxbytes/1024/1024/1024 end ))) - (ROUND(SUM(bytes/1024/1024/1024))) "AVAILABLE_IN_GB" from dba_data_files where tablespace_name='ODN_SMALL_DATA';

<end node> 5P9i0s8y19Z
<node>
DB CREATION
1
STEPS FOR DB CREATION
=======================
STANDARDS FOR INIT PARAMETERS
================================


IN CASE OF ORACLE 8I
===================

IN CASE OF ORACLE 9
===================I









connect ' / as sysdba '
startup nomount

-- Run the database creation script ---

@$ORACLE_HOME/rdbms/admin/catalog.sql        ------->  To create all the data dictionary views
@$ORACLE_HOME/rdbms/admin/cataproc.sql      ------->  To create all the standard packages

connect system/manager
@$ORACLE_HOME/sqlplus/admin/pupbld.sql        ------->  To create the user product profile

<end node> 5P9i0s8y19Z
<node>
FULL-TABLE-SCAN
1
select sp.object_owner,sp.object_name,
(select sql_text from v$sqlarea sa
where sa.address = sp.address
and sa.hash_value =sp.hash_value) sqltext,
(select executions from v$sqlarea sa
where sa.address = sp.address
and sa.hash_value =sp.hash_value) no_of_full_scans,
(select lpad(nvl(trim(to_char(num_rows)),' '),15,' ')||' | '||lpad(nvl(trim(to_char(blocks)),' '),15,' ')||' | '||buffer_pool
from dba_tables where table_name = sp.object_name
and owner = sp.object_owner) "rows|blocks|pool"
from v$sql_plan sp
where operation='TABLE ACCESS'
and options = 'FULL'
and object_owner IN ('SYSADM')
order by 1,2;
==========================================================
col OBJECT_NAME for a30
col OBJECT_OWNER for a15
col OPERATION for a15
select c.USERNAME||'#'||c.STATUS||'#'||c.OSUSER||'#'||c.MACHINE||'#'||c.PROGRAM||'#'||c.CLIENT_INFO||'#'||a.OBJECT_OWNER||'#'||a.OBJECT_NAME||'#'||a.OPERATION||'#'||a.OPTIONS||'#'||b.SQL_TEXT||'#'||a.HASH_VALUE||'#'||b.MODULE from V$SQL_PLAN a, V$SQL b,v$session c where a.OPTIONS like '%FULL%' AND a.OPERATION like '%TABLE%' and a.address=b.address and b.address=c.sql_address and a.object_owner not in ('SYS','SYSTEM','PLLDBA','DBADMIN');


===============================

<end node> 5P9i0s8y19Z
<node>
ROLLBACK
1
                         Rollback Segment
                         ================                     

Rollback Segment Status :
----------------------------------------

select v$rollstat
.usn||' # '||round(rssize/(1024*1024),2)||' # '||
optsize/(1024*1024)||' # '||status||' # '||name
from v$rollstat,v$rollname
where v$rollstat
.usn=v$rollname
.usn;



Rollstat info
===========
select a.usn,a.name,
b.shrinks,b.wraps,
b.optsize,b.hwmsize from 
v$rollname a,v$rollstat b
where a.usn=b.usn;


Transactions held in Rollback Segment:
--------------------------------------
col "USED BLOCKS" for a20
SELECT
SUBSTR(V$SESSION
.SID,1,8) SID,
TO_CHAR(SPID) SPID,
TO_CHAR(PROCESS) PROCESS,
SUBSTR(NVL(V$SESSION
.PROGRAM,MACHINE),1,20) PROGRAM,
TO_CHAR(USED_UBLK*8192/1024/1024) "USED BLOCKS",
SUBSTR(V$SESSION_WAIT.EVENT,1,18) EVENT,
ROUND(V$SESSION.SECONDS_IN_WAIT/(60*60),2) HR, R
.STATUS,
START_TIME,
SYSDATE, SUBSTR(R
.USN,1,6) USN
FROM 
V$SESSION,V$TRANSACTION,V$ROLLSTAT R, 
V$SESSION_WAIT, V$PROCESS 
WHERE SADDR=SES_ADDR 
AND XIDUSN=R
.USN AND V$SESSION
.SID=V$SESSION_WAIT
.SID AND
PADDR=V$PROCESS
.ADDR 


Trasactions held in RBS (w.r.t name of rbs)
================================
SELECT SUBSTR(V$SESSION
.SID,1,8) SID,
TO_CHAR(SPID) SPID,
TO_CHAR(PROCESS) PROCESS,
SUBSTR(R
.USN,1,6) USN,
n
.name,
SUBSTR(NVL(V$SESSION
.PROGRAM,MACHINE),1,20) PROGRAM,
TO_CHAR(USED_UBLK*8192/1024/1024) USED,
SUBSTR(EVENT,1,18) EVENT,
ROUND(SECONDS_IN_WAIT/(60*60),2) HR, R
.STATUS,
START_TIME,
SYSDATE FROM 
V$SESSION,V$TRANSACTION,V$ROLLSTAT R, 
v$rollname n,
V$SESSION_WAIT, V$PROCESS 
WHERE SADDR=SES_ADDR 
AND XIDUSN=R
.USN AND V$SESSION
.SID=V$SESSION_WAIT
.SID AND
PADDR=V$PROCESS
.ADDR
and XIDUSN = n
.usn ;

Status of rollback segments
=======================
select 
seg
.segment_name,
n
.usn,
seg
.status,
seg
.tablespace_name
from dba_rollback_segs seg,v$rollname n
where seg
.segment_name=n
.name;

                          ROLLBACK SEGMENT
                          ================ 
select 
(1-(sum(waits)/sum(gets)))*100 
from 
v$rollstat;

SELECT SID,substr(nvl(a
.program,a
.machine),1,20) "PROGRAM"
FROM V$SESSION a

WHERE SADDR IN (SELECT SES_ADDR
FROM V$TRANSACTION);

select name from v$rollname
where usn=15


UNDOMANANGEMENT = AUTO
==========================


DBA_UNDO_EXTENTS
UNDO_STAT
UNDO$

<end node> 5P9i0s8y19Z
<node>
Transactions
1
<end node> 5P9i0s8y19Z
<node>
TEMP
1
To check available free space in TEMP TABLESPACE : 
===========================================
select round(sum(free_blocks*8192/1024/1024/1024)) from 
v$sort_segment   where 
tablespace_name = 'PSTEMP'; 

SORT SEGMENT
===============
select substr(TABLESPACE_NAME,1,10),round(TOTAL_BLOCKS*8192/1024/1024/1024) TOTAL_SPACE_IN_GB,
round(USED_BLOCKS*8192/1024/1024/1024) USED_SPACE_IN_GB ,round(FREE_BLOCKS*8192/1024/1024/1024) FREE_SPACE_IN_GB
from gv$sort_segment;

SORT USAGE
============
select USERNAME,SESSION_ADDR,TABLESPACE,CONTENTS,sum(round(BLOCKS*8192/1024/1024)) "USED_MB"
from v$sort_usage 
group by username,SESSION_ADDR,TABLESPACE,CONTENTS;

select USERNAME,SESSION_NUM,TABLESPACE,CONTENTS,sum(round(BLOCKS*8192/1024/1024))
from v$sort_usage 
group by username,SESSION_NUM,TABLESPACE,CONTENTS;

TEMP_USAGE
============
SELECT a.username, a.sid, a.serial#, a.osuser, b.tablespace, b.blocks*8*1024/1024/1024 MB, c.sql_text
FROM v$session a, v$tempseg_usage b, v$sqlarea c
WHERE a.saddr = b.session_addr
AND c.address= a.sql_address
AND c.hash_value = a.sql_hash_value
ORDER BY b.tablespace, b.blocks;

SELECT a.username, a.sid, a.serial#, a.osuser, b.tablespace, round(BLOCKS*8192/1024/1024/1024) GB, a.sql_hash_value
FROM v$session a, v$tempseg_usage b
WHERE a.saddr = b.session_addr
ORDER BY b.tablespace, b.blocks;


For 9i
=====
PROGRAMS CURRENTLY USING TEMP TABLESPACE
===============================================

SELECT s
.username, s
.sid, s
.program,u
.tablespace, u
.contents, u
.extents, u
.blocks * 8192/1024/1024
FROM v$session s, v$sort_usage u
WHERE s
.saddr=u
.session_addr and s
.sid=536; 


This query lists information needed by a DBA to trace the use of the TEMP tablespace. 
=======================================================================


SELECT s.sid "SID",s.username "User",s.program "Program", u.tablespace "Tablespace",
u.contents "Contents", u.extents "Extents", u.blocks*8/1024 "Used Space in MB", q.sql_text "SQL TEXT",
a.object "Object", k.bytes/1024/1024 "Temp File Size"
FROM v$session s, v$sort_usage u, v$access a, dba_temp_files k, v$sql q
WHERE s.saddr=u.session_addr
and s.sql_address=q.address
and s.sid=a.sid
and u.tablespace=k.tablespace_name;




FOR 8i
======
PROGRAMS CURRENTLY USING TEMP TABLESPACE
===============================================
select a
.program,a
.sid,a
.status,b
.BLOCKS*8192/1024/1024,b
.TABLESPACE,b
.CONTENTS
from v$session a,
v$sort_usage b
where a
.saddr=b
.session_addr;


FOR RAC
========
select round(sum(free_blocks*8192/1024/1024/1024)) from 
gv$sort_segment   where 
tablespace_name = 'TEMP'; 


select inst_id, tablespace_name, total_blocks, used_blocks, free_blocks   from gv$sort_segment;  

Total_blocks will show the total amount of temp segment space available for each instance.  Used_Blocks will show how much of that space has been utilized.  Free_blocks will show how much space has been ALLOCATED to this  instance.  If you are getting ORA-1652 errors on an instance, you will likely see that used_blocks = total_blocks and free_blocks = 0.








TEMPORARY TABLESPACES
=====================

select tablespace_name,sum(bytes)
from dba_temp_files
where tablespace_name = 'TEMP'
group by tablespace_name;

select tablespace_name,sum(bytes)
from dba_data_files
where tablespace_name = 'TEMP'
group by tablespace_name;



===================================================================


Who is sorting how much in Oracle 8.1

--------------------------------------------------------------------------------

One question that still appears fairly frequently on the comp.database.oracle.server news group is 'Who is using the TEMP segment right now'. This question can (nearly) be answered by a dynamic performance view called v$sort_usage introduced in Oracle 8. However, if you use this view, you will notice that only one user ever appears to be doing any sorting - and their user id always matches the userid that you are using to query the view !

If you examine the view definition, you will discover why this is the case - the view below is from Oracle 8.1.6, and includes the column SEGTYPE that does not exist in Oracle 8.1.5:

	Name                            Type
	------------------------------- -----------
	USER                            VARCHAR2(30)
	SESSION_ADDR                    RAW(4)
	SESSION_NUM                     NUMBER
	SQLADDR                         RAW(4)
	SQLHASH                         NUMBER
	TABLESPACE                      VARCHAR2(31)
	CONTENTS                        VARCHAR2(9)
	SEGTYPE                         VARCHAR2(9)
	SEGFILE#                        NUMBER
	SEGBLK#                         NUMBER
	EXTENTS                         NUMBER
	BLOCKS                          NUMBER
	SEGRFNO#                        NUMBER

USER is not a very good name for a column! How often you do 'select user from dual' to find out the identity of the user running a particular process ?

The problem can easily be circumvented. All we need to do is to log on as SYS and create a modified version of the v$sort_usage view that substitutes a legal column name for the problem one. For example, the following is adequate::

rem
rem	Script:		fix_sort_usage.sql
rem	Author:		Jonathan Lewis
rem	Dated:		June 2000
rem
rem	Purpose:	Work around a bug in v$sort_usage
rem
rem	Note:
rem	This version is commented to run on 8.1.5
rem	It adds the session id (SID) that is missing from v$sort_usage.
rem


create or replace view v$_sort_usage_2 (
	username, sid, session_addr, session_num, sqladdr, sqlhash, 
	tablespace, contents, /* segtype, */ segfile#, segblk#, 
	extents, blocks, segrfno#
)
as
select
	username,
	sid,
	ktssoses,
	ktssosno,
	prev_sql_addr,
	prev_hash_value,
	ktssotsn,
	decode(ktssocnt,
		0, 'PERMANENT',
		1, 'TEMPORARY'
	),
/*
	decode(ktssosegt,
		1, 'SORT',
		2, 'HASH',
		3, 'DATA',
		4, 'INDEX',
		5, 'LOB_DATA',
		6, 'LOB_INDEX' ,
		   'UNDEFINED'
	),
*/
	ktssofno,
	ktssobno,
	ktssoexts,
	ktssoblks,
	ktssorfno 
from 
	x$ktsso,
	v$session 
where
	ktssoses = v$session.saddr 
and	ktssosno = v$session.serial#    
and	x$ktsso.inst_id = sys_context('userenv','instance')
;

rem
rem	Could make this v$sort_usage to hide the erroneous view completely
rem

create or replace view v$sort_usage_2 as 
select * from V$_sort_usage_2;

grant select on v$sort_usage_2 to public;

create public synonym v$sort_usage_2 for v$sort_usage_2;


Note that there is a section of code commented out that is relevant only to Oracle 8.1.6 - not only can you see who is using space in the temporary segment, you can also see what they are using it for. A particular threat to watch out for is users that get too keen on using Temporary LOBS (a feature new to 8.1.6), or are pushing large volumes of data into 'proper' temporary tables (a feature of 8.1)


--------------------------------------------------------------------------------

Sample Output

USERNAME                  SID SESSION_ SESSION_NUM SQLADDR     SQLHASH
------------------ ---------- -------- ----------- -------- ----------
TABLESPACE          CONTENTS   SEGFILE#    SEGBLK#    EXTENTS     BLOCKS   SEGRFNO#
------------------ --------- ---------- ---------- ---------- ---------- ----------
JPL1                        8 05AA2D30         163 061360C4 3375885015
TEMP               TEMPORARY         33       7201          1       1024          1

If you want to pursue users who are using a lot of temporary space, the SQLHASH corresponds to the HASH_VALUE column of the v$sql view, so you can easily find out the text that actually causes this space to be used. Unless, of course, it is being used during a 'create index' or 'create table' statement.

<end node> 5P9i0s8y19Z
<node>
Oracle and Application Process
1
select to_char(sysdate,'dd-mon-yy:hh24:mi:ss') from dual;


To get Oracle Process from OS Process:
==================================
select substr(sid,1,5) SID,process,
substr(program,1,40)  PROGRAM,type,status
from v$session 
where type != 'BACKGROUND';

11217
Spid :  (Knowing Server Process ID)
====
select s
.sid,p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program,s
.status
from v$session s, v$process p
where s
.paddr = p
.addr and p
.spid=4676

Sid :  (Knowing Oracle Session ID)
===

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program,s
.logon_time "log time"
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid in (518)

==========================================================

To Check all active session with sql_text
==================================

select c
.spid b1, b
.osuser c1, b
.username c2, b
.sid b2, b
.serial# b3,
a
.sql_text
from v$sqltext a, v$session b,
v$process c
where a
.address    = b
.sql_address
and b.status= 'ACTIVE' 
and b
.paddr=c
.addr
and a
.hash_value = b
.sql_hash_value
order by c
.spid,a
.hash_value,a
.piece
/    


SID accesing objets ( Knowing Object name )
===============


Program name using a specific table
=============================

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid in ( select 
sid from v$access
where object in
('EJ001T'))

select sid from v$access
where object in ('IC010TB','IC010HB')

select sid from v$access
where object in ('IC010TB','IC010HB')

Program accessing objects
======================

select substr(object,1,40) 
from v$access
where sid in
(select sid from
v$session where
nvl(program,machine) 
like '%ftupld%')

Application Process:
================

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and nvl(s
.program,machine) like '%mf041ct%'

TO GET SID OF PROGRAM wrt THE PROGRAMS PROCESS ID

=================================================
select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr  and s
.process =4676

STATUS
========
select count(*),nvl(program,machine)
from v$session
where status like '%INACTIVE%'
group by nvl(program,machine)
order by count(*)

<end node> 5P9i0s8y19Z
<node>
Idle programs
2
Program,spid,process running for more than four hour
====================================================

select substr(s
.sid,1,8) SID,substr(s
.process,1,8)PROCESS,substr(p
.spid,1,8)SPID,substr(s
.program,1,30)PROGRAM,
substr(round(sw
.seconds_in_wait/3600,2),1,5) 
"HRS_WAIT"
from v$session s,v$session_wait sw,
V$process p where s
.paddr=p
.addr and s
.sid=sw
.sid and sw
.state='WAITING' 
and round(sw
.seconds_in_wait/3600,2) > 4
order by substr(s
.program,1,30)



and s
.machine like '%cath%' 
order by round(sw
.seconds_in_wait/3600,2) desc


select LOCAL_TRAN_ID from dba_2pc_pending

<end node> 5P9i0s8y19Z
<node>
Redo-Log-generation
1
No. of archive's generated & it's Size
======================================

SELECT Start_Date,
       Start_Time,
       Num_Logs,
       Round(Num_Logs * (Vl.Bytes / (1024 * 1024)),
             2) AS Mbytes,
       Vdb.NAME AS Dbname
  FROM (SELECT To_Char(Vlh.First_Time,
                       'YYYY-MM-DD') AS Start_Date,
               To_Char(Vlh.First_Time,
                       'HH24') || ':00' AS Start_Time,
               COUNT(Vlh.Thread#) Num_Logs
          FROM V$log_History Vlh
         GROUP BY To_Char(Vlh.First_Time,
                          'YYYY-MM-DD'),
                  To_Char(Vlh.First_Time,
                          'HH24') || ':00') Log_Hist,
       V$log Vl,
       V$database Vdb
 WHERE Vl.Group# = 1
 ORDER BY Log_Hist.Start_Date,
          Log_Hist.Start_Time;

========================================================
fix:

To find sessions generating lots of redo, you can use either of the following 
methods. Both methods examine the amount of undo generated. When a transaction 
generates undo, it will automatically generate redo as well.

The methods are:
1) Query V$SESS_IO. This view contains the column BLOCK_CHANGES which indicates
   how much blocks have been changed by the session. High values indicate a 
   session generating lots of redo.

   The query you can use is:

SELECT s.sid, s.serial#, s.username, s.program,
i.block_changes
FROM gv$session s, gv$sess_io i
WHERE s.sid = i.sid
ORDER BY 5 desc, 1, 2, 3, 4;

   Run the query multiple times and examine the delta between each occurrence
   of BLOCK_CHANGES. Large deltas indicate high redo generation by the session.

2) Query V$TRANSACTION. This view contains information about the amount of
   undo blocks and undo records accessed by the transaction (as found in the 
   USED_UBLK and USED_UREC columns).
 
  The query you can use is:

SELECT s.sid, s.serial#, s.username, s.program, 
t.used_ublk, t.used_urec
FROM v$session s, v$transaction t
WHERE s.taddr = t.addr
ORDER BY 5 desc, 6 desc, 1, 2, 3, 4;

   Run the query multiple times and examine the delta between each occurrence
   of USED_UBLK and USED_UREC.Large deltas indicate high redo generation by 
   the session.

You use the first query when you need to check for programs generating lots of 
redo when these programs activate more than one transaction. The latter query 
can be used to find out which particular transactions are generating redo.

===================================================================================================================================


SELECT s.sid, s.serial#, s.username, s.program,
 i.block_changes
FROM v$session s, v$sess_io i
WHERE s.sid = i.sid
ORDER BY 5 desc, 1, 2, 3, 4;


==============================================================================================================
Archive log generation on hourly basis
==============================


select to_char(FIRST_TIME,'YYYYMMDD HH24'), count(1), round(sum(BLOCKS*BLOCK_SIZE/1024/1024)) size_mb
from v$archived_log
where FIRST_TIME > sysdate -2
group by to_char(FIRST_TIME,'YYYYMMDD HH24')
order by 1 desc

select to_char(FIRST_TIME,'YYYYMMDD'),count(1), round(sum(BLOCKS*BLOCK_SIZE/1024/1024/1024)) size_GB
from v$archived_log
where FIRST_TIME > sysdate -5
group by to_char(FIRST_TIME,'YYYYMMDD')
order by 1 desc
==============================================================================================================
select to_char(FIRST_TIME,'YYYYMMDD HH24'), count(1), round(sum(BLOCKS*BLOCK_SIZE/1024/1024)) size_mb
from v$archived_log
where trunc(FIRST_TIME) = '13-MAR-2010'
group by to_char(FIRST_TIME,'YYYYMMDD HH24')
order by 1 desc

<end node> 5P9i0s8y19Z
<node>
SQL TEXT
1
                     SQL that is being executed
                     ==========================    

QUERY TO CHECK SQL THAT IS BEING EXECUTED
===========================================
select sql_text||' # '||hash_value
from v$sqltext where hash_value 
in(select hash_value from 
v$open_cursor where 
sid =284)
order by hash_value, piece;

CURRENT SQL BEING EXECUTED
=============================

select sql_text
 from gv$sqltext
where (hash_value,address) in
(select sql_hash_value,sql_ADDRESS from
gv$session where sid in (318))
order by piece;


select sql_text||' # '||hash_value
 from v$sqltext
where (hash_value,address) in
(select sql_hash_value,sql_ADDRESS from
v$session where sid in (2,
466,
192,
727,
759,
268,
408))
order by piece;


select sql_text
 from v$sqltext
where (hash_value,address) in
(select sql_hash_value,sql_ADDRESS from
v$session where sid in (138))
order by hash_value,piece;

select operation||' # '||options
||object_name from v$sql_plan 
where hash_value=1244912662

select sid,sql_text from v$open_cursor where sql_text like '%GAT%'

SQL TEXT HAPPENING ON THE OBJECT
==================================

select v$session.sid,sql_text,
nvl(v$session
.program,v$session
.machine)
from v$open_cursor, v$session
where 
v$session
.sid = v$open_cursor
.sid and
sql_text like '%UP%';

select gv$session.inst_id,gv$session.sid,sql_text,
nvl(gv$session
.program,gv$session
.machine)
from gv$open_cursor, gv$session
where 
gv$session
.sid = gv$open_cursor
.sid and
sql_text like '%compa%';

QUERY FOR A SPECIFIC OBJECT
============================

select sql_text,
nvl(v$session
.program,machine),v$session
.process
from v$open_cursor, v$session
where 
v$session
.sid = v$open_cursor
.sid and v$session
.sid in(69);
and
sql_text like '%e%';
==============================

SELECT * FROM 
  (SELECT hash_value,address,substr(sql_text,1,40) sql,
          buffer_gets, executions, buffer_gets/executions "Gets/Exec"
     FROM V$SQLAREA
    WHERE buffer_gets > 100000 AND executions > 10
   ORDER BY buffer_gets DESC)
WHERE rownum <= 10;

<end node> 5P9i0s8y19Z
<node>
TOP-10-SQL-QUERIES
1
 PURPOSE
-------

This article contains a few ready-made queries on V$SQLAREA
for identifying the top 10 most resource-consuming SQL statements
with a variety of criteria.

The thresholds used are the same as used by default in Statspack:

Buffer Gets : 10,000
Physical Reads : 1,000
Executions : 100
Parse Calls : 1,000
Sharable Memory : 1,048576
Version Count : 20

SCOPE & APPLICATION
-------------------

The queries found here may be useful to Database Administrators, 
Application Developers, Oracle Support Engineers and generally
anyone involved in an Oracle Database Performance Tuning activity.

EXAMPLE V$SQLAREA QUERIES
-------------------------
 
Top 10 by Buffer Gets:

set linesize 100
set pagesize 100
SELECT * FROM
(SELECT substr(sql_text,1,40) sql,
        buffer_gets, executions, buffer_gets/executions "Gets/Exec",
        hash_value,address
   FROM V$SQLAREA
  WHERE buffer_gets > 10000
 ORDER BY buffer_gets DESC)
WHERE rownum <= 10
;

Top 10 by Physical Reads:

set linesize 100
set pagesize 100
SELECT * FROM
(SELECT substr(sql_text,1,40) sql,
        disk_reads, executions, round(disk_reads/executions) "Reads/Exec",hash_value
   FROM V$SQLAREA a,v$session b 
  WHERE disk_reads > 1000 and a.address=b.SQL_ADDRESS
 ORDER BY disk_reads DESC)
WHERE rownum <= 10
;
Top 10 by Executions:

set linesize 100
set pagesize 100
select * from 
(SELECT sid,substr(sql_text,1,40) sql,
        executions, rows_processed, round (rows_processed/executions) "Rows/Exec",hash_value FROM V$SQLAREA a,v$session b
  WHERE executions > 100 and a.address=b.SQL_ADDRESS
 ORDER BY executions DESC )
WHERE rownum <= 10;


Top 10 by Parse Calls:

set linesize 100
set pagesize 100
SELECT * FROM
(SELECT substr(sql_text,1,40) sql,
        parse_calls, executions, hash_value,address
   FROM V$SQLAREA
  WHERE parse_calls > 1000
 ORDER BY parse_calls DESC)
WHERE rownum <= 10
;

Top 10 by Sharable Memory:

set linesize 100
set pagesize 100
SELECT * FROM 
(SELECT substr(sql_text,1,40) sql,
        sharable_mem, executions, hash_value,address
   FROM V$SQLAREA
  WHERE sharable_mem > 1048576
 ORDER BY sharable_mem DESC)
WHERE rownum <= 10
;

Top 10 by Version Count:

set linesize 100
set pagesize 100
SELECT * FROM 
(SELECT substr(sql_text,1,40) sql,
        version_count, executions, hash_value,address
   FROM V$SQLAREA
  WHERE version_count > 20
 ORDER BY version_count DESC)
WHERE rownum <= 10
;

<end node> 5P9i0s8y19Z
<node>
OBJECTACCESS
1
PROGRAM CURRENTLY ACCESSING OBJECTS
=========================================

select substr(sid,1,7)"SID",
substr(event,1,30)"event",
substr(segment_name,1,10)"SEGMENT_NAME",
segment_type,
seconds_in_wait
from v$session_wait a, dba_extents b
where sid=32 and a
.p1=b
.file_id and a
.p2 between b
.block_id and b
.block_id+blocks-1;

<end node> 5P9i0s8y19Z
<node>
STATS QUERIES
1
                        SYSTEM STAT                        
                        ===========

select
substr(event,1,25) event,
round(AVERAGE_WAIT/100,2) ag
from
v$system_event
order by round(AVERAGE_WAIT/100,2);
--------------------------------------------------------------------
                          SESSION STAT
                          ============                          

select
substr(event,1,25) event,
round(sum(AVERAGE_WAIT/100),2) avg
from
v$session_event
group by event
order by round(sum(AVERAGE_WAIT/100),2);
--------------------------------------------------------------------
                          SESSIONWAIT STAT
                          =================                          
select 
substr(program,1,25) prog,
substr(event,1,20) event,
count(*)
from
v$session a, v$session_wait b 
where a
.sid = b
.sid  and 
event not like '%SQL%'
and
event not like '%rdbms%'
group by  program ,event 
order by count(*)  ;

select a.sid,
substr(a.program,1,25) prog,
substr(b.event,1,20) event,
count(*)
from
v$session a, v$session_wait b 
where a.sid = b.sid  and b.event not like '%SQL%' and b.event not like '%rdbms%'
group by a.sid, a.program ,b.event 
order by count(*)  ;


                          IO FILE STAT
                          ==========

select  
substr(NAME,1,60), 
substr(to_char(PHYRDS),1,10),
substr(to_char(PHYWRTS),1,10)
from 
v$filestat a, v$datafile b
where a
.file# = b
.file#
order by (PHYRDS+PHYWRTS);


                          REQUEST FAILURES
                          ================ 

select 
request_failures 
from 
v$shared_pool_reserved;
-------------------------------------------------------------------
                             LOG BUFFER
                             ==========

select 
substr(name,1,25) name,
value 
from 
v$sysstat 
where 
name in ('redo log space requests','redo log space wait time');


Monitoring UNDOSTAT
========================

SELECT TO_CHAR(BEGIN_TIME, 'MM/DD/YYYY HH24:MI:SS') BEGIN_TIME,
         TO_CHAR(END_TIME, 'MM/DD/YYYY HH24:MI:SS') END_TIME,
         UNDOTSN, UNDOBLKS, TXNCOUNT, MAXCONCURRENCY AS "MAXCON"
         FROM v$UNDOSTAT WHERE rownum <= 144;

<end node> 5P9i0s8y19Z
<node>
Customised Views
1
                        Customized Views
                        ================
The view pct1$ gives you the details about tablespaces

The view dbf1$ gives you the details about datafiles

The view brtl1$ gives you the details about objects


DBA_2PC_PENDING

select LOCAL_TRAN_ID from dba_2pc_pending

<end node> 5P9i0s8y19Z
<node>
LATCHES
1
                              LATCH
                              =====

select 
substr(name,1,25) name,
substr(to_char(gets),1,10) gets,
substr(to_char(misses),1,10) misses,
(misses/(gets+misses))*100 ratio
from 
v$latch
where
gets <> 0
and
misses <> 0 
order by (misses/(gets+misses))*100;
RATIO:(1-(misses/(gets+misses)))*100
--------------------------------------------------------------------
                          LATCHFREE
                          =========
select
parse_calls,executions,
round(parse_calls/executions,2),
first_load_time,sql_text
from v$sqlarea
where hash_value
in
(
select hash_value
from
v$open_cursor
where
sid=689) and
parse_calls<>0 and
executions<>0 and
parse_calls/executions = 1;
                            ######
select
sql_text
from v$sqltext
where 
hash_value
in
(
select hash_value
from
v$open_cursor
where
sid=1211) 
order by hash_value,piece;

select
sql_text
from v$sqltext
where hash_value
in
(
select sql_hash_value
from
v$session
where
sid=31) 
order by hash_value,piece;

--------------------------------------------------------------------
                    Identifing a Particular Latch
                    =============================     
select 
substr(event,1,10) event,
p1,p2,p3
from 
v$session_wait 
where
event like '%latch free%'; 

select 
substr(event,1,20)||' # '||
p1||' # '||p2||' # '||p3
from 
v$session_wait 
where sid=689 ;

select 
gets,misses,
sleeps,spin_gets,
SLEEP1,SLEEP2,SLEEP3,SLEEP4
 from 
v$latch 
where 
latch# = p2;

<end node> 5P9i0s8y19Z
<node>
HIT RATIOS
1
                         BUFFER HIT RATIO
                         ================= 

select 
substr(name,1,25),
value 
from 
v$sysstat 
where 
statistic# in (38,39,40);
RATIO: (1-(Physical Reads/(Db Block Gets+Consistent Gets)))*100
--------------------------------------------------------------------
                         LIBRARY HIT RATIO
                         ================= 

select 
(1-(sum(reloads)/sum(pins)))*100 
from
v$librarycache;
--------------------------------------------------------------------
                          ROW HIT RATIO
                          ============== 

select 
(1-(sum(getmisses)/sum(gets)))*100
from 
v$rowcache;
--------------------------------------------------------------------
                          SORT HIT RATIO
                          =============== 

select 
substr(name,1,25) name,
value 
from 
v$sysstat 
where 
name like '%sort%';
RATIO: (1-(Disk Reads/(Disk Reads+Memory Reads)))*100

<end node> 5P9i0s8y19Z
<node>
MTS
1
                                Mts
                                ====
SELECT a 
.sid, VALUE/1024/1024
FROM 
v$sesstat a, mtsv$ b 
where a
.sid=b
.sid  and
statistic#=21
and a
.value/1024/1024 > 15
order by VALUE; 


select * from mtsv$ order by 1

<end node> 5P9i0s8y19Z
<node>
NO OF PROGRAMS RUNNING
1
                      NUMBER OF PROGRAMS RUNNING  
                      ===============================

select 
substr(nvl(program,machine),1,25) ,
count(*)
from
v$session
group by nvl(program,machine)
order by count(*);

select 
substr(nvl(program,machine),1,25) ,
count(*) 
from 
v$session
where substr(nvl(program,machine),1,25)  like  '%mc001cb%'
group by nvl(program,machine)
order by count(*);

select 
substr(nvl(program,machine),1,25) ,
sid
from 
v$session
where substr(nvl(program,machine),1,25) like '%mc001cb%';

<end node> 5P9i0s8y19Z
<node>
PARSING
1
                                 Hard Parsing
                                 ============= 
SELECT a 
.sid||' # '||
VALUE||' # '||program
FROM 
v$sesstat a, v$session b
where a
.sid=b
.sid and statistic#=154 and
value<>0
order by VALUE ; 

<end node> 5P9i0s8y19Z
<node>
CPU USED BY PROGRAMS
1
                    TO LIST SESSIONS STATISTICS
                  ================================

(replace statistics# by the number below for the respective Stats)
11 - CPU used when call started
12 - CPU Used by session
22 - Enque Timeouts
23 - Enque Waits
24 - Enque Deadlocks
163 - sorts(disk)

Program Wise CPU USAGE
==============================

select substr(nvl(a
.program,a
.machine),1,20) "PROGRAM", substr(a
.process,1,8) "PROCESS", substr(d
.spid,1,8) "SPID", lpad(round(b
.value/(100*60)),8,' ') "MINUTES",
to_char(logon_time,'DD/MM/YY HH:MM:SS') 
logon
from v$session a,v$sesstat b,
v$statname c, v$process d
where a
.sid = b
.sid and a
.paddr = d
.addr and b
.statistic# = c
.statistic# and c
.statistic# = 12 and b
.value > 10000 and a
.type <> 'BACKGROUND'
order by 4 desc;
                      
                                 ###2###

select substr(nvl(a
.program,a
.machine),1,19) "PROGRAM", substr(a
.process,1,8) "PROCESS", substr(d
.spid,1,8) "SPID", substr(to_char(lpad(round(b
.value/(100*60)),8,' ')),1,4)  "MIN",
to_char(logon_time,'DD-MON HH:MM') 
logon,substr(event,1,15) event,
substr(to_char(seconds_in_wait),1,5) waitssec
from v$session a,v$sesstat b,
v$statname c, v$process d,v$session_wait e
where  a
.sid = b
.sid and a    
.sid = e
.sid and a
.paddr = d
.addr and b
.statistic# = c
.statistic# and c
.statistic# = 12 and b
.value > 10000 and a
.type <> 'BACKGROUND'
order by round(b
.value/(100*60)) desc;



                                 ###3###  grouped wrt program
select nvl(a
.program,a
.machine)"PROGRAM",
sum(substr(to_char(lpad(round(b
.value/(100*60)),8,' ')),1,4))  "total MIN"
from v$session a,v$sesstat b,
v$statname c, v$process d,v$session_wait e
where  a
.sid = b
.sid and a    
.sid = e
.sid and a
.paddr = d
.addr and b
.statistic# = c
.statistic# and c
.statistic# = 12 and b
.value > 10000 and a
.type <> 'BACKGROUND'
group by nvl(a
.program,a
.machine)
order by sum(substr(to_char(lpad(round(b
.value/(100*60)),8,' ')),1,4)) desc;

<end node> 5P9i0s8y19Z
<node>
INDEXES
1
INDEX QUERY
=====================
select index_name||' # '||column_name
||' # '||column_position from dba_ind_columns
where table_name='EJ001TB'



select index_name,
column_name,column_position 
from dba_ind_columns
where index_owner='GTDBA'
and table_name='TB_WORKCASHFLOW'  
ORDER BY index_name,
column_position,column_name;

<end node> 5P9i0s8y19Z
<node>
to list users having sysuser and sysdba privileges
1
To view the list of users who have the SYSOPER and SYSDBA
database privileges. REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE
=========================================================
select * from v$pwfile_users;
--------------------------------------------------------------------

<end node> 5P9i0s8y19Z
<node>
CHECKPOINT
1
                            CHECKPOINT
                            ==========

select  
substr(name,1,40) name,
value 
from 
v$sysstat 
where 
name like '%background%check%';



THRESHOLD: (BackgroundCheckpointStarted-
           BackgroundCheckpointCompleted)     < 1

<end node> 5P9i0s8y19Z
<node>
IDLE PROGRAMS
1
Program,spid,process running for more than four hour
====================================================

select substr(s
.sid,1,8) SID,substr(s
.process,1,8)PROCESS,substr(p
.spid,1,8)SPID,substr(s
.program,1,30)PROGRAM,
substr(round(sw
.seconds_in_wait/3600,2),1,5) 
"HRS_WAIT"
from v$session s,v$session_wait sw,
V$process p where s
.paddr=p
.addr and s
.sid=sw
.sid and sw
.state='WAITING' 
and round(sw
.seconds_in_wait/3600,2) > 10
and s
.type<>'BACKGROUND'
and s
.program not like '%proc%'
order by seconds_in_wait;


Program,spid,process running for more than four hour with the type of program that you
want to search:

select substr(s
.sid,1,8) SID,substr(s
.process,1,8)PROCESS,substr(p
.spid,1,8)SPID,substr(s
.program,1,30)PROGRAM,
substr(round(sw
.seconds_in_wait/3600,2),1,5) 
"HRS_WAIT"
from v$session s,v$session_wait sw,
V$process p where s
.paddr=p
.addr and s
.sid=sw
.sid and sw
.state='WAITING' 
and round(sw
.seconds_in_wait/3600,2) > 4
and substr(s
.program,1,30) like '%pcrdprocivr%'
order by  substr(s
.program,1,30)

<end node> 5P9i0s8y19Z
<node>
EVENTS
1
To find object on which scattered read is happening.
---------------------------------------------------
ps -ef | grep <PID value of top> = gives the database name.

go to the database and issue

To see all the events without their count
-----------------------------------------
select distinct(event) from v$session_wait;

To see all the events with their count
--------------------------------------
select event,count(*)
from v$session_wait
group by event
order by count(*);

select sid, event
from v$Session_wait
Where event like '%latch free%';


EVENT wrt TH SID
==============
select event||' # '||seconds_in_wait
From v$Session_wait
Where sid =237;

select EVENT||' # '||
TOTAL_WAITS from v$session_event
where sid=237 order by total_waits


To see the events and their waiting time
----------------------------------------
select event,sum(seconds_in_wait)/(60*60) 
from v$session_wait group by event;



Different Events from V$session
===============================
SQL*Net message from client
SQL*Net message to client
SQL*Net more data from client
SQL*Net more data to client
SQL*Net message from dblink
SQL*Net more data from dblink
SQL*Net break/reset to dblink
db file parallel read
db file parallel write
db file scattered read
db file sequential read
buffer busy waits
buffer free waits
enqueue
latch free
async disk IO
rdbms ipc message
pmon timer
smon timer
log file sync
ges remote message


OBJECT ON WHICH SCATTERED IS HAPPENEING
==========================================

select substr(sid,1,7)"SID",
substr(event,1,30)"event",
substr(segment_name,1,10)"SEGMENT_NAME",
segment_type,
seconds_in_wait
from v$session_wait a, dba_extents b
where event like '%db%scatt%' and a
.p1=b
.file_id and a
.p2 between b
.block_id and b
.block_id+blocks-1;

current sql being executed:
-------------------------------------------
select sql_text from v$sqltext
where (hash_value,address) in
(select sql_hash_value,sql_ADDRESS from
v$session where sid in(33)) order by piece;

To find the program that uses the object:
================================
SELECT DISTINCT PROGRAM FROM
V$SESSION WHERE SID IN ( SELECT SID FROM V$ACCESS
WHERE OBJECT ='<segmentname got from earlier query>');

SELECT DISTINCT PROGRAM FROM
V$SESSION WHERE SID IN ( SELECT SID FROM V$ACCESS
WHERE OBJECT ='NOTEPAD');


to get object statistics for 
the object got from earlier query(substitute the object id to this query):
------------------------------------------------------------------------------------------------

select * from brtl1$
where object='NOTEPAD';

select * from brtl1$
where object='CCTAB';


select * from brtl1$
where object='HS310';

note : the value of extent column retuns the level of fragmentation of the object


current sql being executed:
-------------------------------------------
select sql_text from v$sqltext
where (hash_value,address) in
(select sql_hash_value,sql_ADDRESS from
v$session where sid in(618)) order by piece;



EVENT
======
select event,state from v$session_wait where sid=34;

TIME WAITING
============
select seconds_in_wait
from v$session_wait
where sid=618;

<end node> 5P9i0s8y19Z
<node>
break/reset
2
SELECT EVENT,COUNT(*)
FROM V$SESSION_WAIT
GROUP BY EVENT
ORDER BY COUNT(*);

if gives this event:

SQL*Net break/reset to dblink


select sid from v$session_wait
where event like '%break/reset%';

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid in (474,1681);



SSPID      PROCESS   SID                          SERIAL#                      PROGRAM
--------- --------- ---------------------------- ---------------------------- --
7873      18108      1103                         4173 mcqn@cath1 (TNS V1-V3)
13546     27013      1473                        26188 mcqn@cath1 (TNS V1-V3)



then to kill it if its a mcq program:

go to viewer
type 15

Choice : ks
Arguments <process id got from previous query>


SPID      PROCESS   SID                          PROGRAM
--------- --------- ---------------------------- ------------------------------
7873      18108                             1103 mcqn@cath1 (TNS V1-V3)
13546     27013                             1473 mcqn@cath1 (TNS V1-V3)

<end node> 5P9i0s8y19Z
<node>
Alert log errors
1
alert errors

1. go to backup.mad
2. viewer
/usr1/spool/oraerr*
shift -g
shift -e
latest report


1)ORA-1652: unable to extend temp segment by 128 in tablespace TEMP
==================================================================

SELECT * FROM PERFSTAT
.DBS_SORT;


go to dbmon database and issue query

select substr(program,1,25) "PROGRAM",
to_char(report_date,'ddmmyy:hh24:mi:ss')
"REPORT_DATE",
size_in_mb, sql_text from perfstat
.sort_monitor where db_nm = 'CATH'
and to_char(report_date,'ddmmyy:hh24:mi')
between ('190704:00:46') and ('190704:03:15');


replacing dbname with that given in the error log and time as specified in the error log.


get the query thats using more memory.this is the reason why the temp segment cant extend.


2)this type:
Tue Jun 15 11:10:40 2004
Errors in file /usr/oracle/rdbms/log/gilscmf_ora_21213.trc:
ORA-00600: internal error code, arguments: [12227], [], [], [], [], [], [], []
==================================================================

go to conerned database and supply pg sh and search for the trace file string. cut and paste the query.



3)this type:
Tue Jun 15 00:37:36 2004
ORA-01555 caused by SQL statement below (Query Duration=18076 sec, SCN: 0x0181.502f6754)
==================================================================
merc on narmada /oratrc/merc/bdump
edc: /oratrc/edc/bdump   alert_newedc.log
capp on chenab: /chenab/oratrc/capp/bdump
capp on stmt: ?/rdbms/log
edc on edc machine: /oratrc/edc/bdump
more alert_newedc.log 

bill on narmada /oratrc/bill/bdump


Machine :- edc (up)   Dbname :- newedc  use sms id: offus.mad

on the concerned database find path of alert log file by using query:

select name,value from v$parameter
where name like '%background%';

select name,value from v$parameter
where name like '%user_dump%';


/ora9014/app/oracle/admin/roioasis/udump

go to the alert log file and do search wrt the date (eg: Tue Jun 15 00:37:36 2004) and paste the query that caused the error.




4)Sat Jun 26 10:35:23 2004
ORA-000060: Deadlock detected. More info in file /chenab/oratrc/capp/udump/capp_ora_14378.trc.
==================================================================
go to concerned db and say pg sh and look for the trace file path and cut and paste the query responsible for the deadlock.



note: capp database entries in stmt machine can be ignored as the database has been moved to chenab machine.
---------------------------------------------------------------------------------------------------------



Sat Jul 10 04:00:08 2004
Errors in file /usr/app/oracle/product/7.3.3/rdbms/log/snp0_395.trc:
ORA-12012: error on auto execute of job 206
ORA-12008: error in snapshot refresh path
ORA-12203: TNS:unable to connect to destination

ORA-06512: at "SYS.DBMS_SNAPSHOT", line 271
ORA-06512: at "SYS.DBMS_IREFRESH", line 413
ORA-06512: at "SYS.DBMS_REFRESH", line 171
ORA-06512: at line 1


select what,interval,job,broken
from dba_jobs where broken ='Y';

<end node> 5P9i0s8y19Z
<node>
error-nos
2
Current number of sessions reached in cath.

RES_NAME   CURR_UTIL  MAX_UTIL   INIT_ALLOC LIM_VALUE
---------- ---------- ---------- ---------- ----------
sessions   1501       1715             1985       1985


02050
CAUSE: This problem may have caused because of network or system failure during 
2 phase commit. Due to which data exclusively locked by in doubt transactions 
may not be available to statements of other transactions.


01555
give query


00600
program:    ?  @cmfl (TNS interface)
	
Current SQL statement for this session:
INSERT INTO "PLAN_TABLE"("STATEMENT_ID","TIMESTAMP","OPERATION","OPTIONS","OBJEC
T_NODE","OBJECT_OWNER","OBJECT_NAME","OBJECT_INSTANCE","OBJECT_TYPE","SEARCH_COL
UMNS","ID","PARENT_ID","POSITION","OTHER") VALUES (:1,SYSDATE@!,:2,:3,:4,:5,:6,:
7,:8,:9,:10,:11,:12,:13)

<end node> 5P9i0s8y19Z
<node>
brokenjobs
2
to check for broken jobs use dba_jobs view 

select what,interval,job,broken
from dba_jobs
where broken='Y';


for broken jobs : broken will be = Y.

<end node> 5P9i0s8y19Z
<node>
ENQUES
1
====== TO FIND IF ENQUEUES ARE PRESENT =====

select sw
.sid from v$session_wait sw
where sw
.event like '%enque%'

====== Session details of an enqueue process =====
select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid in (select sw
.sid from v$session_wait sw
where sw
.event like '%enque%')

<end node> 5P9i0s8y19Z
<node>
tablespace in backup mode
1
To list tablespaces in backup mode
============================

select d
.name,t
.name,b
.status from
v$backup b,
v$datafile d,
v$tablespace t
where b
.file# = d
.file#
and d
.ts# = t
.ts#
and b
.status ='ACTIVE';


select name from v$datafile where file# in
(select file# from v$backup where status='ACTIVE')


select distinct tablespace_name from dba_data_files where
file_id in (select file# from v$backup where status='ACTIVE')

<end node> 5P9i0s8y19Z
<node>
high load
1
monitor top

get spid  eg: 11031	(the first field of top o/p)


use pg 11031 to find on which database the process is.

go to the database and use spid query:


select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and p
.spid  in(18056);

will give the sid, oracle processid and the program. 

verify from seniors , if the program can be killed.

<go to (deviation) if needed>

if yes then
kill spid by

pg 11031
click on pid value and click enter key.

then pid <oracle process id got from previous query>
click on pid value and click enter key.


deviation:
you can also check the state of the program by:

process trace.

and the time of wait by:

select seconds_in_wait
from v$session_wait
where sid=920;
================================================================================

SELECT EVENT,COUNT(*)
FROM V$SESSION_WAIT
GROUP BY EVENT
ORDER BY COUNT(*);

if gives this event:

SQL*Net break/reset to dblink


select sid,status from v$session_wait
where event like '%break/reset%';

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and s
.sid  in (223, 918,737,256,712);


select sid,serial#,status
from v$session
where sid in(223,737,918,712,256);


SID                          SERIAL#                      STATUS
---------------------------- ---------------------------- --------
                         223                         1789 ACTIVE
                         256                         1610 ACTIVE
                         712                        26089 ACTIVE

for the active status one do:

use sid query to find the program name:


SPID      PROCESS   SID                          PROGRAM
--------- --------- ---------------------------- ------------------------------
18370     12311                              737 mcqn@cath1 (TNS V1-V3)
32145     31596                              712 mcqn@cath1 (TNS V1-V3)
3429      30694                              918 mcqn@cath1 (TNS V1-V3)
12460     31967                              256 mcqn@cath1 (TNS V1-V3)
7764      28729                              223 mcqn@cath1 (TNS V1-V3)



option 15
ks 
223,1789

wait for few minutes till u get
ORA-00031: session marked for kill


SQL> Disconnected from Oracle8 Enterprise Edition Release 8.0.6.3.0 - Production
With the Partitioning and Objects options
PL/SQL Release 8.0.6.3.0 - Production
Press Any Key to Continue

then supply next sid and serial# and so on



after all then
issue query:

select sid,serial#,status
from v$session
where sid in(223,737,918,712,256);

then to kill it:

go to viewer
type

Choice : ks
Arguments <spid got from previous query>

<end node> 5P9i0s8y19Z
<node>
Hanging
1
CALLER SAYS A PROGRAM IS HANGING.

asks WHY?

USE PG PROGRAM NAME.. THIS GIVES PROCESS ID OF PROGRAM.. USE IT IN QUERY TO GET SID ... 
USE SID TO CHECK WHAT EVENT IS HAPPENING FOR THAT SID...

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr  and s
.process =21106


select event
From v$Session_wait
Where sid = 430


ALSO CHECK SQL TEXT BEING PROCESSED BY THAT SID TO FIGURE OUT WHY THE PROGRAM IS HANGING.

select sql_text||' # '||hash_value
from v$sqltext where hash_value 
in(select hash_value from 
v$open_cursor where 
sid =430)
order 
by hash_value, piece


IF FTS is happening then check the query to find out if the object being accessed is thru
 an index or not. Else escalate for query tuning.

<end node> 5P9i0s8y19Z
<node>
Free-Space-Tablespace
1
select ts.tablespace_name, 
to_char(sum(nvl(fs.bytes,0))/1048576, '99,999,990.99') as MB_FREE, 
count(*) as FRAGMENTS, 
to_char(max(nvl(fs.bytes,0))/1048576, 
'99,999,990.99') as BIGGEST_BIT    
 from user_free_space fs, user_tablespaces ts     
where fs.tablespace_name(+) = ts.tablespace_name     
group by ts.tablespace_name;
f

<end node> 5P9i0s8y19Z
<node>
Pending Transactions
1
To clear pending transactions
=============================
Views Regarding pending Transactions
=====================================
dba_2pc_pending
pending_sub_session$

STATES OF TRANSACTIONS
======================
prepared
collecting
commited

SQL> EXECUTE DBMS_TRANSACTION.ROLLBACK_FORCE('11.4.27098');

PL/SQL procedure successfully completed.

SQL> alter system  set "_smu_debug_mode"=4;

System altered.

SQL> commit;

Commit complete.

SQL> EXECUTE DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY('11.4.27098');

PL/SQL procedure successfully completed.


EXECUTE DBMS_TRANSACTION.COMMIT_FORCE('16.8.49');

<end node> 5P9i0s8y19Z
<node>
Backup taken
1

Tablespaces kept in backup Mode:
===========================

select distinct tablespace_name
from dba_data_files
where file_id in (select file#
from v$backup
where status = 'ACTIVE');

<end node> 5P9i0s8y19Z
<node>
Two Task Programs
1
on cath:

SID   WAIT-MIN EVENT         SOFAR-MB TOT_WRK-MB
----- -- ------------- ------- -------
658   0  db file scatt    2895    3168

4 row(s) selected

dBASQL>  select p
     2>  .spid,s
     3>  .process,s
     4>  .sid,substr(nvl(s
     5>  .program,s
     6>  .machine),1,30) program
     7>  from v$session s, v$process p
     8>  where s
     9>  .paddr = p
    10>  .addr and s
    11>  .sid in (658)


SPID      PROCESS   SID                          PROGRAM
--------- --------- ---------------------------- ------------------------------
2544      22247                              658 phys-chenab

1 row(s) selected




pg 22247 on chenab machine gives


--------------------------------------------------------------------------------
     UID   PID  PPID  C    STIME      TTY  S    TIME  CPU  MEM CMD
--------------------------------------------------------------------------------
  oracle 22247     1  0 14:56:27        ?  S    0:00  0.0  7.4 oraclecapp (LOCAL
=NO)


means program is from capp database:
on capp database:


select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and p
.spid =22247;



SPID         PROCESS      SID   PROGRAM
------------ ------------ -------------------     -----------------------------------
22247        14918             80     tech10@phys-kaveri (TNS V1-V3)


tech10 programs can be killed if its invloving excessive IO.mcqn programs can also be killed but b4hand  consult with SI.

To Kill:
=======

kill 22247 on chenab machine.check for ppid 1 (yes) also.

kill 14918 in kaver.check for ppid 1 (yes) also.

and  go back to cath and pg 2544 on cath. if it exists ask naresh what to do.

<end node> 5P9i0s8y19Z
<node>
RBS Cleaning
1
RBS cleaning.
===========

(sid,spid,process)


From report take spid and use spid query to find if transaction exists.

get process id and grep it to find the program using the rbs.

if its a dispacter process then dont kill the spid... kill the process only.
if its a cron job then dont kill.

2 or 3 days old mcqn@cath1 can be killed if its occupying rbs space.

select sid,program,status from v$session
where program like 'exp%';


select process,
program,machine,
to_char(logon_time,
'dd-hh24:mi:ss')
 from v$session 
where saddr in 
(select ses_addr from 
v$transaction where xidusn in 
(select usn from  
v$rollstat where xacts>10))
and program like '%rt400%'
order by logon_time desc


sample:

deloasis 565      23120     23112     23     phys-yamuna          .0078125                           
		SQL*Net message fr      125.1 ONLINE          06/30/04 23:41:44    06-JUL-04


select sql_text,
nvl(v$session
.program,machine),v$session
.process
from v$open_cursor, v$session
where 
v$session
.sid = v$open_cursor
.sid and v$session
.sid in()

The above is a rbs entry existing in deloasis database. program name isnt existing. But machine name suggests that the program is from yamuna itself.

when i grep the spid i get 

-------------------------------------------------------------------------------
     UID   PID  PPID  C    STIME      TTY  S    TIME  CPU  MEM CMD
--------------------------------------------------------------------------------
  oracle 23120     1  0   Jun 30        ?  S    0:34  0.0  2.7 oracledeloasis1 (
LOCAL=NO)

since it says database is deloasis1 and local = no it implies that the program is using an "@" to invoke itself on the same database.thats why local=no is exisitng even if the database is the same. in such cases we have to grep the process in the same machine as spoecified in the rbs entries and check if the process still exists. if not we can go ahead and kill the spid  else if its existing then we have to check with seniors to see if the program can be killed.
--------------------------------------------------------------------------------------------


(fews) rbs issue:

check on what rolllback segment the trasaction is residing. check if that rbs is still part of the database. if not leave it. ifyes then kill it if its been lying there for a long time.





select sql_text,
nvl(v$session
.program,machine),v$session
.process
from v$open_cursor, v$session
where 
v$session
.sid = v$open_cursor
.sid and v$session
.sid in(44);


then use process trace to check if process is sleeping. if so kil spid and process.

<end node> 5P9i0s8y19Z
<node>
Version
1
Oracle Version:
============

select * from v$version;

select substr(product,1,30) "Product",
substr(version,1,15) "Version",
substr(status,1,15) "Status"
from product_component_version;

<end node> 5P9i0s8y19Z
<node>
Max sessions
2
caller: Max sessions reached... no new programs can be run.

diagnostic:

chk in v$license if current session have reached max sessons or is very high.

select * from v$license;


chk programs and count of programs running:

select 
substr(nvl(program,machine),1,25) ,
count(*)
from
v$session
group by nvl(program,machine)
order by count(*);

get their spid's and kill old unnecessary programs.

select p
.spid,s
.process,s
.sid,substr(nvl(s
.program,s
.machine),1,30) program
from v$session s, v$process p
where s
.paddr = p
.addr and nvl(s
.program,machine) like 'oracle@phys-yamuna (TNS V%'  

-- eg tech10



kill the spids.


select program from 
v$session where sid  in
(select sid from v$access
 where object='CUMST');

<end node> 5P9i0s8y19Z
<node>
Current No of Sessions
1
FINDING CURRENT NUMBER OF SESSIONS
====================================================
select 
substr(resource_name,1,10)"RES_NAME",
substr(current_utilization,1,10)"CURR_UTIL",
substr(max_utilization,1,10)"MAX_UTIL",
substr(initial_allocation,1,10)"INIT_ALLOC",
substr(limit_value,1,10)"LIM_VALUE"
from v$resource_limit
where resource_name like '%sessions%'


Thu Jul  8 11:22:41 2004
Errors in file /oratrc/cath/bdump/reco_23761.trc:
ORA-00604: error occurred at recursive SQL level 1
ORA-00018: maximum number of sessions exceeded
ORA-02063: preceding 2 lines from HISTNEW

Current number of sessions reached in cath.

RES_NAME   CURR_UTIL  MAX_UTIL   INIT_ALLOC LIM_VALUE
---------- ---------- ---------- ---------- ----------
sessions   1191       1774             2205       2205

Cause: An infinite loop spawning new sessions.

V$license
========
select substr(sessions_max,1,10)"Max Sessions",
substr(sessions_warning,1,10)"Warning Sessions",
substr(sessions_current,1,10)
"Current Sessions",
substr(sessions_highwater,1,10)
"High Water Sessions",
substr(users_max,1,12)"Max Users"
from
v$license;

<end node> 5P9i0s8y19Z
<node>
Datafileadding
1
Steps for adding a datafile:
============================
To check the free space in the tablespace
========================================
SELECT BYTES/1024/1024,count(*)
from DBA_FREE_SPACE WHERE
TABLESPACE_NAME='FLDETTEMP'
group  by BYTES/1024/1024
order  by BYTES/1024/1024;

To check the next extent of the segment in the tablespace
=========================================================
select next_extent/1024/1024,count(*)
from dba_segments
where tablespace_name='FLDETTEMP'
group by next_extent/1024/1024
order by next_extent/1024/1024;

select * from pct1$ where
tablespace in (
'DLWK1');

select * from dbf1$ where
tablespace in (
'DLWK1');

select * from brtl1$ where
tablespace in (
'DLWK1');

To list all the datafiles belonging to one tablespace
=====================================================
select file_name from
dba_data_files where
tablespace_name in (
'DLWK1');

To list all the datafiles of a database
========================================
set hea off
select name from v$datafile;

To check the total size of a datafile
======================================
select name, file#, bytes/1024/1024
from v$datafile where
datafile name in ('');

To check the creation time of datafile
======================================
select name,file#, creation_time 
from v$datafile where
creation_time like '%-04%';

FROM DBMON DATABASE
=================== 

To report the monthly growth rate of tablespace
===============================================
select ts_name,report_date,sum(growth)
from perfstat
.objgrowth$ where db_nm='CATH'
and ts_name in ('DLWK1')
group by ts_name,report_date
order by ts_name,report_date;

To report the monthly growth rate of database
===============================================
select db_nm,report_date,sum(growth)
from perfstat
.objgrowth$ where db_nm='DELOASIS'
group by db_nm,report_date
order by db_nm,report_date;

<end node> 5P9i0s8y19Z
<node>
Constraints
1
All Constraints of a Specified Table:
============================

select constraint_name||' '||constraint_type
from dba_constraints where 
table_name='FW140';


To Check Table is Partitioned or not:
=============================

select partitioned from dba_tables
where table_name='FW140';

<end node> 5P9i0s8y19Z
<node>
Re-Org
1

To check the table for online re-org possibilites
==============================================
SELECT dt.owner, dt.table_name,
(CASE
WHEN NVL(ind.cnt, 0) < 1 THEN 'Y'
ELSE 'N'
END) AS can_shrink
FROM dba_tables dt,
(SELECT table_name, COUNT(*) cnt
FROM dba_indexes di
WHERE index_type LIKE 'FUNCTION-BASED%'
GROUP BY table_name) ind
WHERE dt.table_name = ind.table_name(+)
AND dt.table_name NOT LIKE 'AQ$%'
AND dt.table_name NOT LIKE 'BIN$%'
AND dt.owner = 'WMTNRPD' and dt.table_name='ACTIVITYLOG'
ORDER BY 1, 2;

 ALTER TABLE B2B71PROD.PRTQUEUECONTENT MODIFY LOB(EVENT) (shrink space compact cascade);

ALTER TABLE B2B71PROD.PRTQUEUECONTENT MODIFY LOB(EVENT) (shrink space cascade)

ALTER TABLE B2B71PROD.PRTQUEUECONTENT MODIFY LOB(EVENT) (shrink space );

<end node> 5P9i0s8y19Z
<node>
Tables
1
Tables Re-Org
=====================================================================================================================================================

select tablespace_name, block_size, initial_extent, next_extent, extent_management, allocation_type,segment_space_management
from dba_tablespaces
where tablespace_name in ('IMAUDITOR_PROD_DATA','JABBER_PROD_DATA','REMOVE_FRAG_TMP');


select owner, table_name,tablespace_name, round((blocks*8192)/1024,2) "tablesize(MB)", round((num_rows*avg_row_len/1024),2) "projected_size(MB)",compression
from dba_tables 
where table_name in ('TC_MESSAGES','TC_MSGARCHIVE','INTERACTIONS','MESSAGES','SESSIONS','TRANSCRIPTS','EXPORTHISTORY','SESSIONGROUPS')
and owner in ('IMAUDITOR_PROD','JABBER_PROD')
order by 1,2;


select owner, table_name,tablespace_name, round((blocks*8192)/1024/1024,2) "tablesize(MB)", 
round((num_rows*avg_row_len/1024/1024),2) "projected_size(MB)",
round((blocks*8192)/1024/1024,2)-round((num_rows*avg_row_len/1024/1024),2) "Fragmented (MB)    ",compression
from dba_tables 
where owner in ('ODSU2') order by 6 desc;


====================================================================================================================================================
TABLE CREATION STPES
====================================================================================================================================================
IF THE TABLESPACE IS LOCALLY MANAGED
====================================================================================================================================================

create table <tname>; (NO NEED TO GIVE STORAGE PARAMETERS)

IF THE TABLESPACE IS DICTIONARY MANAGED
====================================================================================================================================================

create table <tname>;

Table Size in MB


select * from (
select table_name,
round(num_rows* avg_row_len/1024/1024) UsedSizeMb,
round(blocks*8192/1024/1024) TotalSizeMb,
round(blocks*8192/1024/1024) - round(num_rows* avg_row_len/1024/1024) freedSpaceMb,
100*((blocks*8192/1024/1024) - (num_rows* avg_row_len/1024/1024))/(blocks*8192/1024/1024) pct_free,
num_rows, blocks, last_analyzed
from DBA_TAB_STATISTICS
where blocks >1000
and stattype_locked is null
and owner='PSOFT' and table_name in
('PS_FB_GBM_DEPT_TBL')
)
/
====================================================================================================================================================
Segments Vs Avg Row Len
====================================================================================================================================================
col seg_name format a30
col owner format a20
col tbsp format a20
set head on
set pagesize 0
select a.ow "Owner",a.seg "Segment_Name",a.tbsp "Tablespace_Name",a.B "Size in MB",round((b.avg_row_len),2) "Avg_Row_Length(Bytes)",
round((b.blocks*8192)/1024/1024,2)-round((b.num_rows*b.avg_row_len/1024/1024),2) "Fragmented (MB)" from 
(select owner ow,tablespace_name tbsp,segment_name seg ,sum(bytes/1024/1024) B 
from dba_segments where segment_type not like '%PART%' and segment_type not like '%INDEX%' and segment_name not like 'BIN$%'and owner not in ('SYS','SYSTEM',
'XDB',
'OLAPSYS',
'TSMSYS',
'MDSYS',
'SYSMAN',
'ORA_NCYCLE',
'EXFSYS',
'AUDIT_ADMIN',
'WMSYS',
'ORDSYS',
'SCOTT',
'CTXSYS',
'OUTLN',
'DBSNMP',
'DMSYS',
'SQLTXPLAIN') 
group by owner ,tablespace_name ,segment_name 
order by 4 desc) a,dba_tables b where a.seg=b.table_name and a.ow=b.owner order by a.ow,a.B desc


col seg_name format a30
col owner format a20
col tbsp format a20
set head on
set pagesize 0
select a.ow "Owner",a.seg "Segment_Name",a.tbsp "Tablespace_Name",a.B "Size in MB",b. from 
(select owner ow,tablespace_name tbsp,segment_name seg ,sum(bytes/1024/1024) B 
from dba_segments where segment_type not like '%PART%' and segment_type not like '%INDEX%' and segment_name not like 'BIN$%'and owner not in ('SYS','SYSTEM',
'XDB',
'OLAPSYS',
'TSMSYS',
'MDSYS',
'SYSMAN',
'ORA_NCYCLE',
'EXFSYS',
'AUDIT_ADMIN',
'WMSYS',
'ORDSYS',
'SCOTT',
'CTXSYS',
'OUTLN',
'DBSNMP',
'DMSYS',
'SQLTXPLAIN') 
group by owner ,tablespace_name ,segment_name 
order by 4 desc) a 

<end node> 5P9i0s8y19Z
<node>
TABLE CREATION
1
TABLE CREATION CHECKLISTS
===================================

Subject : Sample table creation script with all storage parameters
====================================================

Spool /usr1/spool/<dbname_objname_date.log>

Select machine from v$session where sid=1;
select name from v$database;
show user;
set timing on;
set time on;
set echo on;

create table mt030pb (BR_CD                VARCHAR2(6),
AC_NO                VARCHAR2(10),
BEN_BR_CD            VARCHAR2(6),
BEN_AC_NO            VARCHAR2(10),
DAILY_TXN_LMT        NUMBER(15,2),
SINGLE_TXN_LMT       NUMBER(15,2),
STATUS               CHAR(1),
MKR_ID               VARCHAR2(6),
MKR_DT               DATE,
AUTH_ID              VARCHAR2(6),
AUTH_DT              DATE,
constraint MT030PB_PK1 primary key(BR_CD, AC_NO, BEN_BR_CD, BEN_AC_NO)
USING INDEX TABLESPACE BBYNPTXNIDX
STORAGE (INITIAL 3m NEXT 2m PCTINCREASE 0) pctfree 1 )
TABLESPACE BBYNPTXN
STORAGE (INITIAL 7m NEXT 2m PCTINCREASE 0)
PCTFREE 3 PCTUSED 93;

spool off;


*NOTE-: Please ensure that all the storage parameters (for Dictionary Managed Tablespaces)
              are included for every table and index creation. 
              Especially see for the tablespace name if you are creating index
              or using  constraints during table creation.

*Note-:  Always FTP the script from rad machine to given machine and then run that script. 
             Dont copy and paste in root shell. It will hang the shell.

<end node> 5P9i0s8y19Z
<node>
ProgramCount
1
SELECT COUNT(1), NVL(PROGRAM, MACHINE)
FROM V$SESSION
Where type = 'USER'
GROUP BY NVL(PROGRAM, MACHINE)
ORDER BY COUNT(1);

<end node> 5P9i0s8y19Z
<node>
Index Monitoring
1
http://www.dbazine.com/oracle/or-articles/liu3
http://www.oracle-base.com/articles/10g/IndexMonitoring.php
-- -----------------------------------------------------------------------------------
index_monitoring_status (schema) (table-name or all)
-- -----------------------------------------------------------------------------------
SET VERIFY OFF

SELECT table_name,
       index_name,
       monitoring
FROM   v$object_usage
WHERE  table_name = UPPER('&1')
AND    index_name = DECODE(UPPER('&2'), 'ALL', index_name, UPPER('&2'));

-- -----------------------------------------------------------------------------------
index_usage (table-name) (index-name or all)
-- -----------------------------------------------------------------------------------
SET VERIFY OFF
SET LINESIZE 200

SELECT table_name,
       index_name,
       used,
       start_monitoring,
       end_monitoring
FROM   v$object_usage
WHERE  table_name = UPPER('&1')
AND    index_name = DECODE(UPPER('&2'), 'ALL', index_name, UPPER('&2'));

<end node> 5P9i0s8y19Z
<node>
queries
1
====================================================================================================
Session details
====================================================================================================
set pages 999
set lines 200
col program for a30
col machine for a30
col osuser for a20
col username for a20
alter session set nls_date_format='dd-mon-yyyy hh24:mi:ss';

select sid,program,username,osuser,machine,logon_time,status,event from v$session where username is not null and status='ACTIVE';
select sid,program,username,osuser,machine,logon_time,status from v$session where program ='DBArt800.exe';

select sid,program,username,osuser,machine,logon_time,status,sql_hash_value from v$session where program like '%replicaupdater%';

select 'alter system kill session '||''''||sid||','||serial#||''''||';' from v$session where program not like '%replicaupdater%' and username='PLLP_CCIM1' and status='INACTIVE';
select 'alter system kill session '||''''||sid||','||serial#||''''||';' from v$session where program not like '%replicaupdater%' and username='PLLP_CIM1' and status='INACTIVE';

select 'alter system kill session '||''''||sid||','||serial#||''''||';' from v$session where program not like '%replicaupdater%' and username is not null and status ='INACTIVE';

select sid,program,username,osuser,machine,logon_time,status,sql_hash_value from gv$session where sid in (select sid from v$process a,v$session b where a.addr=b.paddr and a.spid in (  ,
)) order by 2,3,4;

col MESSAGE for a70
Select s.username, l.sid, l.message, l.time_remaining
from v$session_longops l, v$session s
where l.sid = s.sid
and l.time_remaining > 0


select sid,program,username,osuser,machine,logon_time,status from v$session where saddr='00000004C01EDC40';

select sid,program,username,osuser,machine,logon_time,status from gv$session where username like ('RRDB')

select 'alter system kill session '||''''||sid||','||serial#||''''||';' from v$session where status='KILLED';

osuser ='glbatch'  and program like '%psae%';
status='ACTIVE' and 
select sid,program,username,osuser,machine,logon_time,status,last_call_et/60/60 from v$session where machine like '%psoshctm03%';
select sid,program,username,osuser,machine,logon_time,status,last_call_et/60/60 from v$session where sid in ( ));

select 'kill -9 '||spid from v$process a,v$session b where a.addr=b.paddr and b.sid in ( 389,215,325,472,349)
,
 27,
267 ) and b.username='IRRSCK';


select sid,serial# from v$session where sid=245;

select event from v$session_wait where sid in (select sid from v$session where osuser ='glbatch' and machine in ('hbl95a-4401','hbl95a-4402'));

select distinct 'alter system kill session '||chr(39)||to_char(holding_session)||','||to_char(serial#)||chr(39)||';'
from dba_waiters d, v$session v
where d.holding_session = v.sid
/

select * from v$sql_optimizer_env where sql_id = '2xshb8614zp1b' 
and name in ('_gby_hash_aggregation_enabled','_unnest_subquery')



select sql_text
 from v$sqltext
where (hash_value,address) in
(select sql_hash_value,sql_ADDRESS from
v$session where sid in (606))
order by piece;

select sid from v$session where (sql_hash_value,sql_ADDRESS) in (select HASH_VALUE,address from v$sqltext where sql_text like '%PS_JRNL_LN%');

SELECT DECODE(request,0,'Holder: ','Waiter: ')||sid sess,inst_id
        id1, id2, lmode, request, type
   FROM GV$LOCK
  WHERE (id1, id2, type) IN
            (SELECT id1, id2, type FROM GV$LOCK WHERE request>0)
  ORDER BY id1, request;



select spid from v$process where session_addr=6164

select sid from v$process a,v$session b where a.addr=b.paddr and a.spid in (23539)

select spid from v$process a,v$session b where a.addr=b.paddr and b.sid in (select sid from v$session where username='INTCOMDEV');

select spid from v$process a,v$session b where a.addr=b.paddr and b.osuser='magrawal'
username='GWRS2USER';

and status='ACTIVE';

====================================================================================================
To check the update statment progress
====================================================================================================
SELECT
SUBSTR(sql_text, INSTR(sql_text,'INTO "'),30) table_name
, rows_processed
, ROUND( (sysdate-TO_DATE(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60,1) minutes
, TRUNC(rows_processed/((sysdate-to_date(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60)) rows_per_minute
FROM sys.v_$sqlarea
WHERE
sql_text like '%UPDATE PS_ALC_GL_OS_TAO10%'
AND command_type = 6
AND open_versions > 0


====================================================================================================
Check for RMAN Backup details
====================================================================================================

select INPUT_TYPE,START_TIME,END_TIME,OUTPUT_BYTES/1024/1024/1024 "SIZE IN GB",STATUS,ELAPSED_SECONDS/60/60 "ELAPSED" from V$RMAN_BACKUP_JOB_DETAILS;

set linesize 200
col START_TIME format a20
col END_TIME format a20
column STATUS format a15
select SESSION_KEY "KEY" , INPUT_TYPE, STATUS, to_char(START_TIME,'mm/dd/yy hh24:mi') "START_TIME",to_char(END_TIME,'mm/dd/yy hh24:mi') "END_TIME",
round(elapsed_seconds/3600,2) hrs from V$RMAN_BACKUP_JOB_DETAILS order by session_key ;

SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,
       ROUND(SOFAR/TOTALWORK*100,2) "% COMPLETE"
       FROM V$SESSION_LONGOPS
       WHERE OPNAME LIKE 'RMAN%' AND OPNAME NOT LIKE '%aggregate%'
AND TOTALWORK != 0 AND SOFAR <> TOTALWORK;
====================================================================================================
1 Check for orphaned process
====================================================================================================

select spid  from v$process where addr not in (select paddr from v$session) and spid is not null;
====================================================================================================

======================================================================================================
To check SGA freespace
======================================================================================================
SELECT substr(sql_text,1,100) "Stmt", count(*), sum(sharable_mem)  "Mem", 
       sum(users_opening)   "Open",sum(executions)   "Exec"
FROM v$sql 
GROUP BY substr(sql_text,1,100) 
HAVING sum(sharable_mem) > 800000;

select * from v$sgastat where name = 'free memory' ;
======================================================================================================
IO Response Time
======================================================================================================
iostat -xtcnz 5 1000

======================================================================================================
Audit
======================================================================================================
alter session set nls_date_format='dd-mon-yyyy hh24:mi:ss';
col OS_USERNAME for a20
col USERHOST for a20
col OBJ_NAME for a20
select username,OS_USERNAME,USERHOST,TIMESTAMP,ACTION_NAME,OBJ_NAME from dba_audit_trail where owner in ('SYS') and username in ('WORK_FLOW','DBPROFILE','GOMADM')
order by username;
set pages 999
set lines 200
col OS_USERNAME for a20
col USERHOST for a20
col OBJ_NAME for a20
select distinct username,OS_USERNAME,USERHOST,ACTION_NAME from dba_audit_trail where owner in ('SYS') and username in ('WORK_FLOW','DBPROFILE','GOMADM') 
order by username;


select * from DBA_STMT_AUDIT_OPTS where user_name='TSALAMAT_RODEV';


================================================
To Take explain plan for currently running sql - 10g
================================================

SELECT  p.plan_table_output
FROM    v$session s
,       table(dbms_xplan.display_cursor(s.sql_id, s.sql_child_number)) p
where   s.sid = &1
/

select owner,table_name,last_analyzed,num_rows,sample_size from dba_tables where table_name in
('HSTG_MAT_VW_TBL');

 select owner,table_name,last_analyzed,num_rows,sample_size,STALE_STATS,STATTYPE_LOCKED from dba_tab_statistics where table_name in
 ('WIP_PLNDAT') and owner='PSOFT';
================================================================================================
Histroy in execution time
================================================================================================
set linesize 150
col snap_time format a12
select ss.snap_id,to_char(s.begin_interval_time, 'DD-MON HH24:MI') snap_time,
        ss.sql_id,
        ss.plan_hash_value,
 ss.executions_delta execs,
 ss.buffer_gets_delta/decode(ss.executions_delta,0,1,ss.executions_delta) buf_per_exec,
 ss.disk_reads_delta/decode(ss.executions_delta,0,1,ss.executions_delta) phy_per_exec,
 (ss.cpu_time_delta/1000000)/decode(ss.executions_delta,0,1,ss.executions_delta) "cpu_per_exec(Sec)",
 (ss.elapsed_time_delta/1000000)/decode(ss.executions_delta,0,1,ss.executions_delta) "Ela_per_exec(Sec)"
from  dba_hist_snapshot  s,
 dba_hist_sqlstat  ss
where ss.dbid = s.dbid
and ss.instance_number = s.instance_number
and ss.snap_id = s.snap_id
--and ss.plan_hash_value in (3311782617)
and ss.sql_id ='0mxncr87633y5'
and ss.executions_delta > 0
order by ss.plan_hash_value, s.snap_id;
================================================================================================
select owner,segment_name,segment_type,sum(bytes)/1024/1024/1024 from dba_segments where segment_name in
('PS_JRNL_LN','PS_JRNL_HEADER')
group by owner,segment_name,segment_type
order by owner,segment_name,segment_type;

Select * from table(dbms_xplan.display_cursor('4qacdt107uzjv')); <---- for currrent
select * from table(dbms_xplan.display_awr('0mxncr87633y5')); ----------> For AWR

DBA_TAB_STATS_HISTORY
exec dbms_stats.restore_table_stats({owner} ,{table name}, {timestamp});
======================================================================================================
To find the parent and slave processes
======================================================================================================
col username for a12
col username for a12
col "QC SID" for A6
col SID for A6
col "QC/Slave" for A8
col "Requested DOP" for 9999
col "Actual DOP" for 9999
col "Slaveset" for A8
col "Slave INST" for A9
col "QC INST" for A6
set pages 300
set lines 200 
select
decode(px.qcinst_id,NULL,username, 
' - '||lower(substr(pp.SERVER_NAME,
length(pp.SERVER_NAME)-4,4) ) )"Username",
decode(px.qcinst_id,NULL, 'QC', '(Slave)') "QC/Slave" ,
to_char( px.server_set) "SlaveSet",
to_char(s.sid) "SID",
to_char(px.inst_id) "Slave INST",
decode(px.qcinst_id, NULL ,to_char(s.sid) ,px.qcsid) "QC SID",
to_char(px.qcinst_id) "QC INST",
px.req_degree "Req. DOP",
px.degree "Actual DOP"
from gv$px_session px,
gv$session s ,
gv$px_process pp
where px.sid=s.sid (+)
and px.serial#=s.serial#(+)
and px.inst_id = s.inst_id(+)
and px.sid = pp.sid (+)
and px.serial#=pp.serial#(+)
order by 6 , 1 desc
/


column child_wait  format a30
        column parent_wait format a30
        column server_name format a4  heading 'Name'
        column x_status    format a10 heading 'Status'
        column schemaname  format a10 heading 'Schema'
        column x_sid format 9990 heading 'Sid'
        column x_pid format 9990 heading 'Pid'
        column p_sid format 9990 heading 'Parent'
 
        break on p_sid skip 1
 
        select x.server_name
             , x.status as x_status
             , x.pid as x_pid
             , x.sid as x_sid
             , w2.sid as p_sid
             , v.osuser
             , v.schemaname
             , w1.event as child_wait
             , w2.event as parent_wait
        from  v$px_process x
            , v$lock l
            , v$session v
            , v$session_wait w1
            , v$session_wait w2
where x.sid <> l.sid(+)
        and   to_number (substr(x.server_name,2)) = l.id2(+)
        and   x.sid = w1.sid(+)
        and   l.sid = w2.sid(+)
        and   x.sid = v.sid(+)
        and   nvl(l.type,'PS') = 'PS'
        order by 1,2
        /


======================================================================================================
Roles extraction
======================================================================================================

 select 'grant '||PRIVILEGE||' on '||owner||'.'||TABLE_NAME||' to '||GRANTEE||';' from dba_tab_privs where grantee in (
select granted_role from dba_role_privs where grantee='RRDB');

select 'grant '||PRIVILEGE||' on '||owner||'.'||TABLE_NAME||' to '||GRANTEE||';' from dba_tab_privs where table_name='IC_CLMH_CLAIM_H';

===========================
To check status of long operation
===========================
select EXECUTIONS,PARSE_CALLS,rows_processed from v$sql where hash_value=2592670438;
SELECT sid, serial#, context, sofar, totalwork,round(sofar/totalwork*100,2) "% Complete%" FROM v$session_longops
where sid=84;

======================================================================================================
To get object status
======================================================================================================
select owner,object_type,status,count(*) from dba_objects where owner in ('GWRS2DB','GWRSDB')
group by owner,object_type,status
order by owner,object_type,status
/

col object_name for a30
select owner,object_name,object_type from dba_objects where status ='INVALID' 
order by owner,object_type,status
/

======================================================================================================
To check the privileges on pariticular owner's objects given to others
======================================================================================================
select a.owner,b.grantee,a.object_name,a.object_type,a.status,b.privilege from dba_objects a,dba_tab_privs b 
where a.owner='AES' and a.object_name=b.table_name
======================================================================================================
Find the unusable indexes
======================================================================================================

select INDEX_OWNER,INDEX_NAME,PARTITION_NAME,SUBPARTITION_NAME,STATUS from dba_ind_subpartitions
where status='UNUSABLE';

select OWNER,INDEX_NAME,STATUS from dba_indexes where status='UNUSABLE';

select INDEX_OWNER,INDEX_NAME,PARTITION_NAME,STATUS from dba_ind_partitions
where status='UNUSABLE';

select 'alter index '||OWNER||'.'||INDEX_NAME||' rebuild online;' from dba_indexes
where status='UNUSABLE';

select 'alter index '||INDEX_OWNER||'.'||INDEX_NAME||' rebuild partition '||PARTITION_NAME||';' from dba_ind_partitions
where status='UNUSABLE';

select 'alter index '||INDEX_OWNER||'.'||INDEX_NAME||' rebuild subpartition '||SUBPARTITION_NAME||';' from dba_ind_subpartitions
where status='UNUSABLE';

======================================================================================================
To Rebuild indexes for specified partitions - Need to find the indexes and then for partitions
======================================================================================================

select index_name from dba_part_indexes where table_name in 
('CFACKS' )
and owner='CXFADMIN'

select 'alter index '||INDEX_OWNER||'.'||index_name||' rebuild partition '||partition_name ||' parallel nologging;' from dba_ind_partitions where index_name in 
(
'CFCANCELS_SUMMARY_SEQNUM')
and index_owner='CXFADMIN'
and partition_name like ('%2008_12_04%')

======================================================================================================
To gather stats
======================================================================================================
execute dbms_stats.gather_table_stats(OWNNAME=>'ATLAS',TABNAME=>'ACCTSYM',GRANULARITY=>'ALL',CASCADE=>TRUE,METHOD_OPT=>'for all columns size auto',ESTIMATE_PERCENT=>dbms_stats.auto_sample_size);


select snap_id,dbid,BEGIN_INTERVAL_TIME,END_INTERVAL_TIME from dba_hist_snapshot
where begin_interval_time between to_date('07-08-22/09:00:00','YY-MM-DD/HH24:MI:SS')
AND to_date('07-08-22/11:00:00','YY-MM-DD/HH24:MI:SS');

======================================================================================================
To find hidden parameters
======================================================================================================

SET LINESIZE 145
SET PAGESIZE 9999
SET VERIFY   off
COLUMN ksppinm   FORMAT A42   HEAD 'Parameter Name'
COLUMN ksppstvl  FORMAT A39   HEAD 'Value'
COLUMN ksppdesc  FORMAT A60   HEAD 'Description'    TRUNC
SELECT
     ksppinm
    , ksppstvl
    , ksppdesc
  FROM
      x$ksppi x
    , x$ksppcv y
  WHERE
        x.indx = y.indx
    AND TRANSLATE(ksppinm,'_','#') like '#%'
  /

======================================================================================================
To Take explain plan for currently running sql - 9i
======================================================================================================

set pagesize 600
set tab off 
set linesize 140
set echo off
set long 4000
col TQID format A4
col "SLAVE SQL" format A95 WORD_WRAP
col address format A12
col sql_hash format A15
col exec format 9999
col sql_text format A75 WORD_WRAP
repfooter off;
set timing off veri off space 1 flush on pause off termout on numwidth 10;
alter session set "_complex_view_merging"=false;
select hash_value||decode(child_number, 0, '', '/'||child_number) sql_hash, 
          sql_text
from v$sql
where child_number= 0 and hash_value= &hashvalue;



select '| Operation | Name | Starts | E-Rows | A-Rows | Buffers | Reads | Writes | E-Time |' as "Plan Table" from dual
union all /* QWEKLOIPYRTJHH7 */ 
select '------------------------------------------------------------------------------------------------------------------------'
from dual 
union all 
select rpad('| '||substr(lpad(' ',1*(depth))||operation|| decode(options, null,'',' '||options), 1, 33), 34, ' ')||'|'|| 
          rpad(substr(object_name||' ',1, 19), 20, ' ')||'|'|| 
          lpad(decode(starts,null,' ', 
                         decode(sign(starts-1000), -1, starts||' ', 
                         decode(sign(starts-1000000), -1, round(starts/1000)||'K',
                         decode(sign(starts-1000000000), -1, round(starts/1000000)||'M', 
                                           round(starts/1000000000)||'G')))), 8, ' ') || '|' ||
          lpad(decode(cardinality,null,' ',
                         decode(sign(cardinality-1000), -1, cardinality||' ',
                         decode(sign(cardinality-1000000), -1, round(cardinality/1000)||'K',
                         decode(sign(cardinality-1000000000), -1, round(cardinality/1000000)||'M', 
                                            round(cardinality/1000000000)||'G')))), 8, ' ') || '|' ||
          lpad(decode(outrows,null,' ', 
                         decode(sign(outrows-1000), -1, outrows||' ',
                         decode(sign(outrows-1000000), -1, round(outrows/1000)||'K',
                         decode(sign(outrows-1000000000), -1, round(outrows/1000000)||'M', 
                                            round(outrows/1000000000)||'G')))), 8, ' ') || '|' || 
          lpad(decode(crgets,null,' ', 
                         decode(sign(crgets-10000000), -1, crgets||' ', 
                         decode(sign(crgets-1000000000), -1, round(crgets/1000000)||'M',
                                            round(crgets/1000000000)||'G'))), 9, ' ') || '|' || 
          lpad(decode(reads,null,' ', 
                         decode(sign(reads-10000000), -1, reads||' ',
                         decode(sign(reads-1000000000), -1, round(reads/1000000)||'M',
                                            round(reads/1000000000)||'G'))), 8, ' ') || '|' || 
          lpad(decode(writes,null,' ', 
                         decode(sign(writes-10000000), -1, writes||' ', 
                         decode(sign(writes-1000000000), -1, round(writes/1000000)||'M', 
                                            round(writes/1000000000)||'G'))), 8, ' ') || '|' || 
          lpad(decode(etime,null,' ', 
                         decode(sign(etime-10000000), -1, etime||' ', 
                         decode(sign(etime-1000000000), -1, round(etime/1000000)||'M', 
                                            round(etime/1000000000)||'G'))), 8, ' ') || '|' as "Explain plan" 
from 
       (select /*+ no_merge */ 
                  p.HASH_VALUE, p.ID, p.DEPTH, p.POSITION, p.OPERATION, 
                  p.OPTIONS, p.COST COST, p.CARDINALITY CARDINALITY, 
                  p.BYTES BYTES, p.OBJECT_NODE, p.OBJECT_OWNER, 
                  p.OBJECT_NAME, p.OTHER_TAG, p.PARTITION_START,
                  p.PARTITION_STOP, p.DISTRIBUTION, pa.starts, 
                  pa.OUTPUT_ROWS outrows, pa.CR_BUFFER_GETS crgets, 
                  pa.DISK_READS reads, pa.DISK_WRITES writes, 
                  pa.ELAPSED_TIME etime 
        from v$sql_plan_statistics_all pa, 
               V$sql_plan p 
        where p.hash_value = &hashvalue 
           and p.CHILD_NUMBER= 0 
           and p.hash_value = pa.hash_value(+)
           and pa.child_number(+) = 0 ) 
union all 
        select '------------------------------------------------------------------------------------------------------------------------' from dual; 

REM 
REM Print slave sql 
REM 
select /* QWEKLOIPYRTJHH7 */ 
           decode(object_node,null,'', substr(object_node,length(object_node)-3,1) || ',' || 
           substr(object_node,length(object_node)-1,2)) TQID, 
           other "SLAVE SQL" 
from v$sql_plan vp 
where other is not NULL 
    and hash_value = &hashvalue 
    and CHILD_NUMBER= 0;

==============================================
To find out the program which is occupying more memory
==============================================

select substr(sa.sid,1,5) SID,substr(sa.process,1,8)PROCESS,nvl(sa.program,sa.machine),st.value/1024/1024
from v$session sa,v$sesstat st 
where sa.sid=st.sid and sa.type<>'BACKGROUND' 
and st.statistic#=21 and st.value>10000000
order by st.value;
============================================

select username,account_status from dba_users where username = upper('clopez9');

select * from dba_sys_privs where grantee=upper('clopez9');


DBA_2PC_PENDING
~~~~~~~~~~~~~~~
> select LOCAL_TRAN_ID,GLOBAL_TRAN_ID,state,host,FAIL_TIME,FORCE_TIME,advice from DBA_2PC_PENDING;
 
How to purge:
~~~~~~~~~~~~
>exec dbms_transaction.purge_lost_db_entry('the_local_tran_id');
or
>exec dbms_transaction.purge_lost_db_entry('5.75.38968');
 

> exec dbms_transaction.rollback_force('the_local_tran_id');
 
dba_2pc_neighbors
~~~~~~~~~~~~~~~~~
> select LOCAL_TRAN_ID,DATABASE,DBUSER_OWNER,IN_OUT,SESS# from dba_2pc_neighbors where LOCAL_TRAN_ID='1.8.11960881';
 
 
Hiden Parameter
~~~~~~~~~~~~~~~
>alter session set "_smu_debug_mode" = 4;
 

PRD03
~~~~~
> alter session set "_smu_debug_mode" = 4;
> exec DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY('1.8.11960881'); <----LOCAL_TRAN_ID


 set pages 9999
 set lines 200
 col file_name for a60
select file_name,bytes/1024/1024 from dba_data_files where tablespace_name =:a;

<end node> 5P9i0s8y19Z
<node>
DatabaseSize
1
select (a
.data_size+b
.temp_size+c
.redo_size) /(1024*1024*1024) "total_size"
from ( select sum(bytes) data_size
         from dba_data_files ) a,
     ( select nvl(sum(bytes),0) temp_size
         from dba_temp_files ) b,
     ( select sum(bytes) redo_size
         from sys
.v_$log ) c ;

<end node> 5P9i0s8y19Z
<node>
LAST_CALL_ET
1
set pages 999
set lines 200
col STATUS for a10
col spid for a10
col LOGON for a15
col IDLETIME for a15
col USERNAME for a20
col MACHINE for a20
select 
rpad(sid,4,' ') sid,
rpad(spid,5,' ') spid,
rpad(status,10,' ') status,
rpad(to_char(logon_time,
'dd-mon hh:mi'),15,' ') "LOGON",
rpad(floor(last_call_et/3600)||':'||
floor(mod(last_call_et,3600)/60)||':'||
mod(mod(last_call_et,3600),60),12,' ') idletime,
rpad(v$session
.program,25,' ') prg,v$session.username,v$session.machine
from v$session, v$process where 
paddr=addr and type='USER'
order by last_call_et ;

<end node> 5P9i0s8y19Z
<node>
USER_EXPIRE_CHANGE
1
select 'ALTER USER '||USERNAME||' PROFILE '||PROFILE||';'
FROM DBA_USERS 

select 'ALTER USER '||USERNAME||' PROFILE DEFAULT;'
FROM DBA_USERS; 

select 'ALTER USER '||USERNAME||' IDENTIFIED BY VALUES '''||PASSWORD||''';'
FROM DBA_USERS;

<end node> 5P9i0s8y19Z
<node>
Blocking session
1
SELECT s.sid||','||s.serial# SID_SERIAL, kglpnmod "Mode Held", kglpnreq "Request"
     FROM sys.x$kglpn p, sys.v_$session s
    WHERE p.kglpnuse = s.saddr
      AND kglpnhdl   = '000000064B6AFC60'

SELECT sid, event, p1raw, seconds_in_wait, wait_time
     FROM sys.v_$session_wait
    WHERE event = 'library cache pin'
      AND state = 'WAITING'
	  
	  
SELECT kglnaown AS owner, kglnaobj as Object
    FROM sys.x$kglob
    WHERE kglhdadr='000000064342C048'

<end node> 5P9i0s8y19Z
<node>
Tracing
1
alter session set events '20000 trace name errorstack level 3';

<end node> 5P9i0s8y19Z
<node>
RAC_DIA
1
 Overview
--------

This script is intended to provide a user friendly guide to troubleshoot RAC 
hung sessions or slow performance scenerios.  The script includes information 
to gather a variety of important debug information to determine the cause of a 
RAC hang.  The script will create a file called racdiag_<timestamp>.out 
in your local directory while dumping hang analyze dumps in the user_dump_dest(s)
and background_dump_dest(s) on all nodes.  If you are using OpenVMS, see Note 
316838.1 for a VMS specific script.

Script Notes
-------------

This script is intended to be run via sqlplus during a session or system level 
hang in a parallel server environment.  The script should be run as the SYS or 
Internal user.  Before running the script catparr.sql should have been previously
run as SYS on the database to create the appropriate GV$ views.

There are some types of hangs that will prevent this script from running.  If 
the script will not run then it would be advisable to get systemstate dumps 
on each node as the SYS or INTERNAL user to help support debug the problem.  If 
the script will not run properly do the following for each version:

If on 9i run the following on one instance 2-3 times - 1 minute apart:
------------------------------------------------------------------------------
SQL> oradebug setmypid
SQL> oradebug unlimit
SQL> oradebug -g all hanganalyze 3
SQL> oradebug -g all dump systemstate 266

If on 8.X please reference the following note:

  Note 205809.1
  Script to Collect OPS Diagnostic Information (opsdiag.sql)

This script is broken up into different SQL statements that can be used 
individually.  Each SQL statement adds information to help in debugging an 
RAC hang/severe performance scenerio.  

Script
-------

 - - - - - - - - - - - - - - - - Script begins here - - - - - - - - - - - - - - - -

-- NAME:  RACDIAG.SQL 
--    SYS OR INTERNAL USER, CATPARR.SQL ALREADY RUN, PARALLEL QUERY OPTION ON
-- ------------------------------------------------------------------------ 
-- AUTHOR:  
--    Michael Polaski - Oracle Support Services - DataServer Group
--    Copyright 2002, Oracle Corporation      
-- ------------------------------------------------------------------------ 
-- PURPOSE: 
-- This script is intended to provide a user friendly guide to troubleshoot RAC  
-- hung sessions or slow performance scenerios.  The script includes information 
-- to gather a variety of important debug information to determine the cause of an 
-- RAC hang.  The script will create a file called racdiag_<timestamp>.out 
-- in your local directory while dumping hang analyze dumps in the user_dump_dest(s)
-- and background_dump_dest(s) on all nodes.
--
-- ------------------------------------------------------------------------ 
-- DISCLAIMER: 
--    This script is provided for educational purposes only. It is NOT  
--    supported by Oracle World Wide Technical Support. 
--    The script has been tested and appears to work as intended. 
--    You should always run new scripts on a test instance initially. 
-- ------------------------------------------------------------------------ 
-- Script output is as follows:

set echo off
set feedback off
column timecol new_value timestamp
column spool_extension new_value suffix
select to_char(sysdate,'Mondd_hhmi') timecol,
'.out' spool_extension from sys.dual;
column output new_value dbname
select value || '_' output
from v$parameter where name = 'db_name';
spool racdiag_&&dbname&tamp&&suffix
set lines 200
set pagesize 35
set trim on
set trims on
alter session set nls_date_format = 'MON-DD-YYYY HH24:MI:SS';
alter session set timed_statistics = true;
set feedback on
select to_char(sysdate) time from dual;

set numwidth 5
column host_name format a20 tru
select inst_id, instance_name, host_name, version, status, startup_time from gv$instance
order by inst_id;

set echo on

-- Taking Hang Analyze dumps
-- This may take a little while...
oradebug setmypid
oradebug unlimit
oradebug -g all hanganalyze 3
-- This part may take the longest, you can monitor bdump or udump to see if the
-- file is being generated.
oradebug -g all dump systemstate 266

-- WAITING SESSIONS:
-- The entries that are shown at the top are the sessions that have 
-- waited the longest amount of time that are waiting for non-idle wait 
-- events (event column).  You can research and find out what the wait
-- event indicates (along with its parameters) by checking the Oracle 
-- Server Reference Manual or look for any known issues or documentation 
-- by searching Metalink for the event name in the search bar.  Example 
-- (include single quotes): [ 'buffer busy due to global cache' ].
-- Metalink and/or the Server Reference Manual should return some useful 
-- information on each type of wait event.  The inst_id column shows the
-- instance where the session resides and the SID is the unique identifier
-- for the session (gv$session).  The p1, p2, and p3 columns will show 
-- event specific information that may be important to debug the problem.
-- To find out what the p1, p2, and p3 indicates see the next section. 
-- Items with wait_time of anything other than 0 indicate we do not know
-- how long these sessions have been waiting.
--
set numwidth 10
column state format a7 tru
column event format a25 tru
column last_sql format a40 tru
select sw.inst_id, sw.sid, sw.state, sw.event, sw.seconds_in_wait seconds, 
sw.p1, sw.p2, sw.p3, sa.sql_text last_sql
from gv$session_wait sw, gv$session s, gv$sqlarea sa
where sw.event not in 
('rdbms ipc message','smon timer','pmon timer',
'SQL*Net message from client','lock manager wait for remote message',
'ges remote message', 'gcs remote message', 'gcs for action', 'client message', 
'pipe get', 'null event', 'PX Idle Wait', 'single-task message', 
'PX Deq: Execution Msg', 'KXFQ: kxfqdeq - normal deqeue', 
'listen endpoint status','slave wait','wakeup time manager')
and sw.seconds_in_wait > 0 
and (sw.inst_id = s.inst_id and sw.sid = s.sid)
and (s.inst_id = sa.inst_id and s.sql_address = sa.address)
order by seconds desc;

-- EVENT PARAMETER LOOKUP:
-- This section will give a description of the parameter names of the
-- events seen in the last section.  p1test is the parameter value for
-- p1 in the WAITING SESSIONS section while p2text is the parameter
-- value for p3 and p3 text is the parameter value for p3.  The
-- parameter values in the first section can be helpful for debugging
-- the wait event.
--
column event format a30 tru
column p1text format a25 tru
column p2text format a25 tru
column p3text format a25 tru
select distinct event, p1text, p2text, p3text
from gv$session_wait sw
where sw.event not in ('rdbms ipc message','smon timer','pmon timer',
'SQL*Net message from client','lock manager wait for remote message',
'ges remote message', 'gcs remote message', 'gcs for action', 'client message', 
'pipe get', 'null event', 'PX Idle Wait', 'single-task message', 
'PX Deq: Execution Msg', 'KXFQ: kxfqdeq - normal deqeue', 
'listen endpoint status','slave wait','wakeup time manager')
and seconds_in_wait > 0
order by event;

-- GES LOCK BLOCKERS:
-- This section will show us any sessions that are holding locks that
-- are blocking other users.  The inst_id will show us the instance that
-- the session resides on while the sid will be a unique identifier for
-- the session.  The grant_level will show us how the GES lock is granted to 
-- the user.  The request_level will show us what status we are trying to obtain.
-- The lockstate column will show us what status the lock is in.  The last column 
-- shows how long this session has been waiting.
--
set numwidth 5
column state format a16 tru;
column event format a30 tru;
select dl.inst_id, s.sid, p.spid, dl.resource_name1, 
decode(substr(dl.grant_level,1,8),'KJUSERNL','Null','KJUSERCR','Row-S (SS)',
'KJUSERCW','Row-X (SX)','KJUSERPR','Share','KJUSERPW','S/Row-X (SSX)',
'KJUSEREX','Exclusive',request_level) as grant_level,
decode(substr(dl.request_level,1,8),'KJUSERNL','Null','KJUSERCR','Row-S (SS)',
'KJUSERCW','Row-X (SX)','KJUSERPR','Share','KJUSERPW','S/Row-X (SSX)',
'KJUSEREX','Exclusive',request_level) as request_level, 
decode(substr(dl.state,1,8),'KJUSERGR','Granted','KJUSEROP','Opening',
'KJUSERCA','Canceling','KJUSERCV','Converting') as state,
s.sid, sw.event, sw.seconds_in_wait sec
from gv$ges_enqueue dl, gv$process p, gv$session s, gv$session_wait sw
where blocker = 1
and (dl.inst_id = p.inst_id and dl.pid = p.spid)
and (p.inst_id = s.inst_id and p.addr = s.paddr)
and (s.inst_id = sw.inst_id and s.sid = sw.sid)
order by sw.seconds_in_wait desc;

-- GES LOCK WAITERS:
-- This section will show us any sessions that are waiting for locks that
-- are blocked by other users.  The inst_id will show us the instance that
-- the session resides on while the sid will be a unique identifier for
-- the session.  The grant_level will show us how the GES lock is granted to 
-- the user.  The request_level will show us what status we are trying to obtain.
-- The lockstate column will show us what status the lock is in.  The last column 
-- shows how long this session has been waiting.
--
set numwidth 5
column state format a16 tru;
column event format a30 tru;
select dl.inst_id, s.sid, p.spid, dl.resource_name1, 
decode(substr(dl.grant_level,1,8),'KJUSERNL','Null','KJUSERCR','Row-S (SS)',
'KJUSERCW','Row-X (SX)','KJUSERPR','Share','KJUSERPW','S/Row-X (SSX)',
'KJUSEREX','Exclusive',request_level) as grant_level,
decode(substr(dl.request_level,1,8),'KJUSERNL','Null','KJUSERCR','Row-S (SS)',
'KJUSERCW','Row-X (SX)','KJUSERPR','Share','KJUSERPW','S/Row-X (SSX)',
'KJUSEREX','Exclusive',request_level) as request_level, 
decode(substr(dl.state,1,8),'KJUSERGR','Granted','KJUSEROP','Opening',
'KJUSERCA','Cancelling','KJUSERCV','Converting') as state,
s.sid, sw.event, sw.seconds_in_wait sec
from gv$ges_enqueue dl, gv$process p, gv$session s, gv$session_wait sw
where blocked = 1
and (dl.inst_id = p.inst_id and dl.pid = p.spid)
and (p.inst_id = s.inst_id and p.addr = s.paddr)
and (s.inst_id = sw.inst_id and s.sid = sw.sid)
order by sw.seconds_in_wait desc;

-- LOCAL ENQUEUES:
-- This section will show us if there are any local enqueues.  The inst_id will 
-- show us the instance that the session resides on while the sid will be a 
-- unique identifier for.  The addr column will show the lock  address. The type 
-- will show the lock type.  The id1 and id2 columns will show specific parameters 
-- for the lock type.  
--
set numwidth 12
column event format a12 tru
select l.inst_id, l.sid, l.addr, l.type, l.id1, l.id2, 
decode(l.block,0,'blocked',1,'blocking',2,'global') block, 
sw.event, sw.seconds_in_wait sec
from gv$lock l, gv$session_wait sw
where (l.sid = sw.sid and l.inst_id = sw.inst_id) 
and l.block in (0,1)
order by l.type, l.inst_id, l.sid;

-- LATCH HOLDERS:
-- If there is latch contention or 'latch free' wait events in the WAITING
-- SESSIONS section we will need to find out which proceseses are holding 
-- latches.  The inst_id will show us the instance that the session resides 
-- on while the sid will be a unique identifier for.  The username column 
-- will show the session's username.  The os_user column will show the os 
-- user that the user logged in as.  The name column will show us the type
-- of latch being waited on.  You can search Metalink for the latch name in 
-- the search bar.  Example (include single quotes): 
-- [ 'library cache' latch ]. Metalink should return some useful information 
-- on the type of latch.  
--
set numwidth 5
select distinct lh.inst_id, s.sid, s.username, p.username os_user, lh.name
from gv$latchholder lh, gv$session s, gv$process p
where (lh.sid = s.sid  and lh.inst_id = s.inst_id)
and (s.inst_id = p.inst_id and s.paddr = p.addr)
order by lh.inst_id, s.sid;

-- LATCH STATS:
-- This view will show us latches with less than optimal hit ratios
-- The inst_id will show us the instance for the particular latch.  The 
-- latch_name column will show us the type of latch.  You can search Metalink 
-- for the latch name in the search bar.  Example (include single quotes): 
-- [ 'library cache' latch ]. Metalink should return some useful information 
-- on the type of latch.  The hit_ratio shows the percentage of time we 
-- successfully acquired the latch.
--
column latch_name format a30 tru
select inst_id, name latch_name,
round((gets-misses)/decode(gets,0,1,gets),3) hit_ratio, 
round(sleeps/decode(misses,0,1,misses),3) "SLEEPS/MISS"
from gv$latch
where round((gets-misses)/decode(gets,0,1,gets),3) < .99
and gets != 0
order by round((gets-misses)/decode(gets,0,1,gets),3);

-- No Wait Latches:
--
select inst_id, name latch_name,
round((immediate_gets/(immediate_gets+immediate_misses)), 3) hit_ratio, 
round(sleeps/decode(immediate_misses,0,1,immediate_misses),3) "SLEEPS/MISS"
from gv$latch
where round((immediate_gets/(immediate_gets+immediate_misses)), 3) < .99
and immediate_gets + immediate_misses > 0
order by round((immediate_gets/(immediate_gets+immediate_misses)), 3);

-- GLOBAL CACHE CR PERFORMANCE
-- This shows the average latency of a consistent block request.  
-- AVG CR BLOCK RECEIVE TIME should typically be about 15 milliseconds depending 
-- on your system configuration and volume, is the average latency of a 
-- consistent-read request round-trip from the requesting instance to the holding 
-- instance and back to the requesting instance. If your CPU has limited idle time 
-- and your system typically processes long-running queries, then the latency may 
-- be higher. However, it is possible to have an average latency of less than one 
-- millisecond with User-mode IPC. Latency can be influenced by a high value for 
-- the DB_MULTI_BLOCK_READ_COUNT parameter. This is because a requesting process 
-- can issue more than one request for a block depending on the setting of this 
-- parameter. Correspondingly, the requesting process may wait longer.  Also check
-- interconnect badwidth, OS tcp settings, and OS udp settings if 
-- AVG CR BLOCK RECEIVE TIME is high.
--
set numwidth 20
column "AVG CR BLOCK RECEIVE TIME (ms)" format 9999999.9
select b1.inst_id, b2.value "GCS CR BLOCKS RECEIVED", 
b1.value "GCS CR BLOCK RECEIVE TIME",
((b1.value / b2.value) * 10) "AVG CR BLOCK RECEIVE TIME (ms)"
from gv$sysstat b1, gv$sysstat b2
where b1.name = 'global cache cr block receive time' and
b2.name = 'global cache cr blocks received' and b1.inst_id = b2.inst_id 
or b1.name = 'gc cr block receive time' and
b2.name = 'gc cr blocks received' and b1.inst_id = b2.inst_id ;

-- GLOBAL CACHE LOCK PERFORMANCE
-- This shows the average global enqueue get time. 
-- Typically AVG GLOBAL LOCK GET TIME should be 20-30 milliseconds.  the elapsed 
-- time for a get includes the allocation and initialization of a new global 
-- enqueue. If the average global enqueue get (global cache get time) or average 
-- global enqueue conversion times are excessive, then your system may be 
-- experiencing timeouts.  See the 'WAITING SESSIONS', 'GES LOCK BLOCKERS', 
-- 'GES LOCK WAITERS', and 'TOP 10 WAIT EVENTS ON SYSTEM' sections if the 
-- AVG GLOBAL LOCK GET TIME is high.
--
set numwidth 20
column "AVG GLOBAL LOCK GET TIME (ms)" format 9999999.9
select b1.inst_id, (b1.value + b2.value) "GLOBAL LOCK GETS", 
b3.value "GLOBAL LOCK GET TIME",
(b3.value / (b1.value + b2.value) * 10) "AVG GLOBAL LOCK GET TIME (ms)"
from gv$sysstat b1, gv$sysstat b2, gv$sysstat b3
where b1.name = 'global lock sync gets' and
b2.name = 'global lock async gets' and b3.name = 'global lock get time'
and b1.inst_id = b2.inst_id and b2.inst_id = b3.inst_id
or b1.name = 'global enqueue gets sync' and
b2.name = 'global enqueue gets async' and b3.name = 'global enqueue get time'
and b1.inst_id = b2.inst_id and b2.inst_id = b3.inst_id;

-- RESOURCE USAGE
-- This section will show how much of our resources we have used. 
--
set numwidth 8
select inst_id, resource_name, current_utilization, max_utilization,
initial_allocation
from gv$resource_limit
where max_utilization > 0
order by inst_id, resource_name;

-- DLM TRAFFIC INFORMATION
-- This section shows how many tickets are available in the DLM.  If the 
-- TCKT_WAIT columns says "YES" then we have run out of DLM tickets which could
-- cause a DLM hang.  Make sure that you also have enough TCKT_AVAIL.  
--
set numwidth 5
select * from gv$dlm_traffic_controller
order by TCKT_AVAIL;

-- DLM MISC
--
set numwidth 10
select * from gv$dlm_misc;

-- LOCK CONVERSION DETAIL:
-- This view shows the types of lock conversion being done on each instance.
--
select * from gv$lock_activity;

-- TOP 10 WRITE PINGING/FUSION OBJECTS
-- This view shows the top 10 objects for write pings accross instances.  
-- The inst_id column shows the node that the block was pinged on.  The name 
-- column shows the object name of the offending object.  The file# shows the 
-- offending file number (gc_files_to_locks).  The STATUS column will show the 
-- current status of the pinged block.  The READ_PINGS will show us read converts 
-- and the WRITE_PINGS will show us objects with write converts.  Any rows that 
-- show up are objects that are concurrently accessed across more than 1 instance.
--
set numwidth 8
column name format a20 tru
column kind format a10 tru
select inst_id, name, kind, file#, status, BLOCKS, 
READ_PINGS, WRITE_PINGS
from (select p.inst_id, p.name, p.kind, p.file#, p.status, 
count(p.block#) BLOCKS, sum(p.forced_reads) READ_PINGS, 
sum(p.forced_writes) WRITE_PINGS
from gv$ping p, gv$datafile df
where p.file# = df.file# (+)
group by p.inst_id, p.name, p.kind, p.file#, p.status
order by sum(p.forced_writes) desc)
where rownum < 11
order by WRITE_PINGS desc;

-- TOP 10 READ PINGING/FUSION OBJECTS
-- This view shows the top 10 objects for read pings.  The inst_id column shows 
-- the node that the block was pinged on.  The name column shows the object name 
-- of the offending object.  The file# shows the offending file number 
-- (gc_files_to_locks).  The STATUS column will show the current status of the
-- pinged block.  The READ_PINGS will show us read converts and the WRITE_PINGS 
-- will show us objects with write converts.  Any rows that show up are objects 
-- that are concurrently accessed across more than 1 instance.
--
set numwidth 8
column name format a20 tru
column kind format a10 tru
select inst_id, name, kind, file#, status, BLOCKS, 
READ_PINGS, WRITE_PINGS
from (select p.inst_id, p.name, p.kind, p.file#, p.status, 
count(p.block#) BLOCKS, sum(p.forced_reads) READ_PINGS, 
sum(p.forced_writes) WRITE_PINGS
from gv$ping p, gv$datafile df
where p.file# = df.file# (+)
group by p.inst_id, p.name, p.kind, p.file#, p.status
order by sum(p.forced_reads) desc)
where rownum < 11
order by READ_PINGS desc;

-- TOP 10 FALSE PINGING OBJECTS
-- This view shows the top 10 objects for false pings.  This can be avoided by
-- better gc_files_to_locks configuration.  The inst_id column shows the node
-- that the block was pinged on.  The name column shows the object name of the 
-- offending object.  The file# shows the offending file number 
-- (gc_files_to_locks).  The STATUS column will show the current status of the
-- pinged block.  The READ_PINGS will show us read converts and the WRITE_PINGS 
-- will show us objects with write converts.  Any rows that show up are objects 
-- that are concurrently accessed across more than 1 instance.
--
set numwidth 8
column name format a20 tru
column kind format a10 tru
select inst_id, name, kind, file#, status, BLOCKS, 
READ_PINGS, WRITE_PINGS
from (select p.inst_id, p.name, p.kind, p.file#, p.status, 
count(p.block#) BLOCKS, sum(p.forced_reads) READ_PINGS, 
sum(p.forced_writes) WRITE_PINGS
from gv$false_ping p, gv$datafile df
where p.file# = df.file# (+)
group by p.inst_id, p.name, p.kind, p.file#, p.status
order by sum(p.forced_writes) desc)
where rownum < 11
order by WRITE_PINGS desc;

-- INITIALIZATION PARAMETERS:
-- Non-default init parameters for each node.
--
set numwidth 5
column name format a30 tru
column value format a50 wra
column description format a60 tru
select inst_id, name, value, description
from gv$parameter
where isdefault = 'FALSE'
order by inst_id, name;

-- TOP 10 WAIT EVENTS ON SYSTEM
-- This view will provide a summary of the top wait events in the db.
--
set numwidth 10
column event format a25 tru
select inst_id, event, time_waited, total_waits, total_timeouts
from (select inst_id, event, time_waited, total_waits, total_timeouts
from gv$system_event where event not in ('rdbms ipc message','smon timer',
'pmon timer', 'SQL*Net message from client','lock manager wait for remote message',
'ges remote message', 'gcs remote message', 'gcs for action', 'client message', 
'pipe get', 'null event', 'PX Idle Wait', 'single-task message', 
'PX Deq: Execution Msg', 'KXFQ: kxfqdeq - normal deqeue', 
'listen endpoint status','slave wait','wakeup time manager')
order by time_waited desc)
where rownum < 11
order by time_waited desc;

-- SESSION/PROCESS REFERENCE:
-- This section is very important for most of the above sections to find out 
-- which user/os_user/process is identified to which session/process.
--
set numwidth 7
column event format a30 tru
column program format a25 tru
column username format a15 tru
select p.inst_id, s.sid, s.serial#, p.pid, p.spid, p.program, s.username, 
p.username os_user, sw.event, sw.seconds_in_wait sec  
from gv$process p, gv$session s, gv$session_wait sw
where (p.inst_id = s.inst_id and p.addr = s.paddr)
and (s.inst_id = sw.inst_id and s.sid = sw.sid)
order by p.inst_id, s.sid;

-- SYSTEM STATISTICS:
-- All System Stats with values of > 0.  These can be referenced in the
-- Server Reference Manual
--
set numwidth 5
column name format a60 tru
column value format 9999999999999999999999999
select inst_id, name, value
from gv$sysstat
where value > 0 
order by inst_id, name;

-- CURRENT SQL FOR WAITING SESSIONS:
-- Current SQL for any session in the WAITING SESSIONS list
--
set numwidth 5
column sql format a80 wra
select sw.inst_id, sw.sid, sw.seconds_in_wait sec, sa.sql_text sql
from gv$session_wait sw, gv$session s, gv$sqlarea sa
where sw.sid = s.sid (+) 
and sw.inst_id = s.inst_id (+)
and s.sql_address = sa.address 
and sw.event not in ('rdbms ipc message','smon timer','pmon timer',
'SQL*Net message from client','lock manager wait for remote message',
'ges remote message', 'gcs remote message', 'gcs for action', 'client message', 
'pipe get', 'null event', 'PX Idle Wait', 'single-task message', 
'PX Deq: Execution Msg', 'KXFQ: kxfqdeq - normal deqeue', 
'listen endpoint status','slave wait','wakeup time manager')
and sw.seconds_in_wait > 0
order by sw.seconds_in_wait desc; 

-- Taking Hang Analyze dumps
-- This may take a little while...
oradebug setmypid
oradebug unlimit
oradebug -g all hanganalyze 3
-- This part may take the longest, you can monitor bdump or udump to see if the
-- file is being generated.
oradebug -g all dump systemstate 266

set echo off

select to_char(sysdate) time from dual;

spool off

-- ---------------------------------------------------------------------------
Prompt;
Prompt racdiag output files have been written to:;
Prompt;
host pwd
Prompt alert log and trace files are located in:;
column host_name format a12 tru
column name format a20 tru
column value format a60 tru
select distinct i.host_name, p.name, p.value
from gv$instance i, gv$parameter p
where p.inst_id = i.inst_id (+)
and p.name like '%_dump_dest' 
and p.name != 'core_dump_dest';

 - - - - - - - - - - - - - - - -  Script ends here  - - - - - - - - - - - - - - - -


Sample Output:
--------------


TIME
--------------------
AUG-11-2001 12:06:36

1 row selected.


INST_ID INSTANCE_NAME    HOST_NAME            VERSION        STATUS  STARTUP_TIME
------- ---------------- -------------------- -------------- ------- ------------
      1 V9201            opcbsol1             9.2.0.1.0      OPEN    AUG-01-2002 
      2 V9202            opcbsol2             9.2.0.1.0      OPEN    JUL-09-2002 

2 rows selected.

SQL>
SQL> -- Taking Hanganalyze Dumps
SQL> -- This may take a little while...
SQL> oradebug setmypid
Statement processed.
SQL> oradebug unlimit
Statement processed.
SQL> oradebug setinst all
Statement processed.
SQL> oradebug -g def hanganalyze 3
Hang Analysis in /u02/32bit/app/oracle/admin/V9232/bdump/v92321_diag_29495.trc
SQL>
SQL> -- WAITING SESSIONS:
SQL> -- The entries that are shown at the top are the sessions that have
SQL> -- waited the longest amount of time that are waiting for non-idle wait
SQL> -- events (event column).  You can research and find out what the wait
SQL> -- event indicates (along with its parameters) by checking the Oracle
SQL> -- Server Reference Manual or look for any known issues or documentation
SQL> -- by searching Metalink for the event name in the search bar.  Example
SQL> -- (include single quotes): [ 'buffer busy due to global cache' ].
SQL> -- Metalink and/or the Server Reference Manual should return some useful
SQL> -- information on each type of wait event.  The inst_id column shows the
SQL> -- instance where the session resides and the SID is the unique identifier
SQL> -- for the session (gv$session).  The p1, p2, and p3 columns will show
SQL> -- event specific information that may be important to debug the problem.
SQL> -- To find out what the p1, p2, and p3 indicates see the next section.
SQL> -- Items with wait_time of anything other than 0 indicate we do not know
SQL> -- how long these sessions have been waiting.
SQL> --

etc...


Additional Search Words
-----------------------
OPS RAC HANG HUNG REAL APPLICATION CLUSTERS ORAC PERFORMANCE GES GCS ENQUEUE
OPS RAC HANG HUNG REAL APPLICATION CLUSTERS ORAC PERFORMANCE GES GCS ENQUEUE

.  
      
 
Bookmarks   Admin   Profile   Feedback   Sign Out   Help   
 
Copyright  2006, Oracle. All rights reserved.  Legal Notices  and Terms of Use | Privacy Statement  

<end node> 5P9i0s8y19Z
<node>
UNDO-CHECK
1
Doc ID:  Note:460481.1 
=====================
SELECT (UR * (UPS * DBS)) + (DBS * 24) 
AS "Bytes" 
FROM 
(SELECT value 
AS UR
FROM v$parameter
WHERE name = 'undo_retention'), 
(SELECT 
(SUM(undoblks)/SUM(((end_time - begin_time)*86400))) AS UPS 
FROM v$undostat), 
(SELECT value AS DBS 
FROM v$parameter 
WHERE 
name = 'db_block_size') 


select sum(bytes) from dba_free_space where tablespace_name='UNDO_A';
select sum(bytes) from dba_data_files where tablespace_name='UNDOTBS1';


SELECT DISTINCT STATUS, SUM(BYTES), COUNT(*) FROM DBA_UNDO_EXTENTS GROUP BY STATUS;

select autoextensible from dba_data_files where tablespace_name='UNDO';

<end node> 5P9i0s8y19Z
<node>
CALCULATE UNDO 
2
Calculate undo tablespace size
=========================


SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       (TO_NUMBER(e.value) * TO_NUMBER(f.value) *
       g.undo_block_per_sec) / (1024*1024) 
       "NEEDED UNDO SIZE [MByte]"
  FROM (
       SELECT SUM(a.bytes) undo_size
         FROM v$datafile a,
              v$tablespace b,
              dba_tablespaces c
        WHERE c.contents = 'UNDO'
          AND c.status = 'ONLINE'
          AND b.name = c.tablespace_name
          AND a.ts# = b.ts#
       ) d,
       v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
          undo_block_per_sec
         FROM v$undostat
       ) g
 WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/



Calculate undo retention 
======================


SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       ROUND((d.undo_size / (to_number(f.value) *
       g.undo_block_per_sec))) "OPTIMAL UNDO RETENTION [Sec]"
  FROM (
       SELECT SUM(a.bytes) undo_size
          FROM v$datafile a,
               v$tablespace b,
               dba_tablespaces c
         WHERE c.contents = 'UNDO'
           AND c.status = 'ONLINE'
           AND b.name = c.tablespace_name
           AND a.ts# = b.ts#
       ) d,
       v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
              undo_block_per_sec
         FROM v$undostat
       ) g
WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/

<end node> 5P9i0s8y19Z
<node>
Datafile Resize
1
column cmd format a75 word_wrapped

select 'alter database datafile ''' || file_name || ''' resize ' ||
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 )  || 'm;' cmd
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+)
  and ceil( blocks*&&blksize/1024/1024) -
      ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) > 0
/ 

=====================================================================================================================
SELECT
'/* '||to_char(CEIL((f.blocks-e.hwm)*(f.bytes/f.blocks)/1024/1024),99999999)||' M */ ' ||
'alter database datafile '''||file_name||''' resize '||CEIL(e.hwm*(f.bytes/f.blocks)/1024/1024)||'M;' SQL
FROM
DBA_DATA_FILES f,
SYS.TS$ t,
(SELECT ktfbuefno relative_fno,ktfbuesegtsn ts#,
MAX(ktfbuebno+ktfbueblks) hwm FROM sys.x$ktfbue GROUP BY ktfbuefno,ktfbuesegtsn) e
WHERE
f.relative_fno=e.relative_fno and t.name=f.tablespace_name and t.ts#=e.ts#
and f.blocks-e.hwm > 1000
ORDER BY f.blocks-e.hwm DESC

=====================================================================================================================

select ddf.file_name, sum(ddf.bytes)/1024/1024 total_M, sum(dfs.bytes)/1024/1024 free_M
from dba_free_space dfs, dba_data_Files ddf
where dfs.file_id = ddf.file_id and ddf.tablespace_name='IDWH_SML_D_OLD'
group by ddf.file_name

<end node> 5P9i0s8y19Z
<node>
Streams
1
To stop and start Streams
=========================================================================================================
select 'exec dbms_apply_adm.stop_apply('''||APPLY_NAME||''');' from dba_apply;
select 'exec dbms_apply_adm.start_apply('''||APPLY_NAME||''');' from dba_apply;
select 'exec dbms_propagation_adm.STOP_PROPAGATION('''||PROPAGATION_NAME||''');' from dba_propagation;
select 'exec dbms_propagation_adm.start_PROPAGATION('''||PROPAGATION_NAME||''');' from dba_propagation;
select 'exec dbms_capture_adm.stop_Capture('''|| CAPTURE_NAME||''');' from dba_capture;
select 'exec dbms_capture_adm.start_Capture('''|| CAPTURE_NAME||''');' from dba_capture;

exec dbms_apply_adm.set_parameter('APPLY_FROM_PLNDTD10', 'disable_on_error', 'N');


Restart:
exec REP_STREAMS_LCR.start_apply('<apply_process_name>');


Retry:
exec REP_STREAMS_LCR.retry_tran('<txn_id>'); 

http://ln-sharepoint.csintra.net/it/ibdswiki/Wiki%20Pages/Using%20the%20Replication%20Conflict%20Reporting%20Tool.aspx

=========================================================================================================
To check the status for streams
=========================================================================================================
select CAPTURE_NAME,QUEUE_NAME,STATUS from dba_capture;
select APPLY_NAME,QUEUE_NAME,APPLY_CAPTURED,STATUS from dba_apply;
select PROPAGATION_NAME,SOURCE_QUEUE_NAME,STATUS from dba_propagation;
select APPLY_NAME, LOCAL_TRANSACTION_ID, SOURCE_DATABASE, ERROR_MESSAGE from dba_apply_error;

select site,ts at local from dtd_trade.heart_beat;

select apply_name||'   Last applied Message: '||APPLIED_MESSAGE_NUMBER from dba_apply_progress
union
select site||' Last applied TRN date: '||ts at local from DTD_TRADE.heart_beat
union
select 'Total number of apply errors: '||count(*) from dba_apply_error
union
select 'Queue Name  : '||apply_name||' Status : '||status from dba_apply
union
select 'Propagation : '||propagation_name||' Status: '||status from dba_propagation
union
select 'Capture     : '||capture_name||' Status : '||status from dba_capture
/

select ERROR_NUMBER,ERROR_MESSAGE from dba_apply_error;
set serveroutput on
SELECT 'execute '||owner||'.'||'Print_Errors;' from dba_objects where object_name='PRINT_ERRORS' and object_type='PROCEDURE';
execute 
delete or execute error 
sql> execute dbms_apply_adm.execute_all_errors;
sql> execute dbms_apply_adm.delete_all_errors;


If you want to track the progress of the apply process:

SELECT r.APPLY_NAME
  ,ap.status || ' n' || srv.inst_id  STATUS
  , DECODE(srv.state, 'EXECUTE TRANSACTION','EXECUTE TXN', srv.state) STATE
  ,r.DEQUEUED_MESSAGE_NUMBER MSG_NUMBER
  ,to_char(r.DEQUEUE_TIME,'DD-MON HH24:MI') DQ_TIME FROM gV$STREAMS_APPLY_READER r, DBA_APPLY ap, gV$STREAMS_APPLY_SERVER srv WHERE r.inst_id=srv.inst_id AND r.APPLY_NAME = ap.APPLY_NAME AND r.APPLY_NAME = srv.APPLY_NAME

(msg_number is the source SCN).

When the state shows EXECUTE TXN, the apply process is actively running SQL on the local server.


==========================================================================


SQL> select * from gv$transaction_enqueue;

INST_ID ADDR             KADDR                   SID TY        ID1        ID2      LMODE    REQUEST      CTIME      BLOCK
------- ---------------- ---------------- ---------- -- ---------- ---------- ---------- ---------- ---------- ----------
      1 00000001D090E128 00000001D090E160        371 TX     589854     426239          6          0         17          2
      1 00000001D269DA50 00000001D269DA88        606 TX     262176     424697          6          0     302043          2

If the request column value above, is non zero then we have a potential locking situation.

To find out the session, run:-

SQL> select inst_id, sid, serial#, username, program, status from gv$session where taddr in (select addr from gv$transaction_enqueue) ;

INST_ID      SID    SERIAL# USERNAME             PROGRAM                                STATUS
------- -------- ---------- -------------------- -------------------------------------- --------
      1      371       6112 STMON                oracle@sol13d-3001a (J005)             ACTIVE
      1      606        555 VERITAS_I3_ORCL_1    pss_tuner.9i@sol06a-3601 (TNS V1-V3)   INACTIVE


export strpassword=D0ughnut
 
reprule drop cap rule -t DTM_SPECTRE.EVT_RISK
 
reprule add cap rule -t DTM_SPECTRE.EVT_RISK
 
reprule inst app -t DTM_SPECTRE.EVT_RISK

PLNDTD10, PNYDTD10 and PSGDTD10


*** Register TRADE_EXTERNAL_ATTRIBUTE as 3-way replicated table - see below for list of primary key fields
      Ln , Ny ,SG

   reprule  add  cap rule  -t dtd_trade.TRADE_EXTERNAL_ATTRIBUTE
   reprule  inst app  -t  dtd_trade.TRADE_EXTERNAL_ATTRIBUTE

  

***  Register INS_EXTERNAL_ATTRIBUTE as 3-way replicated table - see below for list of primary key fields
         Ln , Ny ,SG

   reprule  add  cap rule  -t dtd_trade.INS_EXTERNAL_ATTRIBUTE
   reprule  inst app  -t  dtd_trade.INS_EXTERNAL_ATTRIBUTE


*** Register EXTERNAL_ATTRIBUTE_CONFIG as 1-way replicated table from London - see below for list of primary

 == Ln  only

   reprule  add  cap rule  -t dtd_trade.EXTERNAL_ATTRIBUTE_CONFIG
   reprule  inst app  -t  dtd_trade.EXTERNAL_ATTRIBUTE_CONFIG

 == Ny	, SG 

CREATE OR REPLACE TRIGGER dtd_trade.TRG_EXTERNAL_ATTRIBUTE_CONFIG 
BEFORE INSERT OR UPDATE OR DELETE
ON DTD_TRADE.EXTERNAL_ATTRIBUTE_CONFIG 
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
begin
	if not pkg_util.isEvent_Handle_Site then
		raise_application_error(-20000,'This table is one-way replicated. Changes to this table can be applied from London DTD only');
	end if;
end;
/


 ********  "register apply handler proc DTD_TRADE.PK_STREAMS_APPLY_DML_HANDLER.TRADE_EXT_ATTR_INSERT for INSERT AND 
            UPDATE actions against table DTD_TRADE.TRADE_EXTERNAL_ATTRIBUTE at databases P**DTD10"

    Ln , Ny ,SG
 reprule add app hdlr -t DTD_TRADE.TRADE_EXTERNAL_ATTRIBUTE INSERT APPLY PK_STREAMS_APPLY_DML_HANDLER.TRADE_EXT_ATTR_INSERT
 reprule add app hdlr -t DTD_TRADE.TRADE_EXTERNAL_ATTRIBUTE UPDATE APPLY PK_STREAMS_APPLY_DML_HANDLER.TRADE_EXT_ATTR_INSERT


====================================================================================================================
Oracle Documentation
Streams Replication Administrator's Guide  
Streams Concepts and Administration  
PL/SQL Packages and Types Reference 
Online Resources (Websites)
Oracle Technology Network: Data Replication and Integration
White Papers
Replication with Oracle Streams  
Oracle Streams Configuration Best Practices: Oracle Database 10g Release 10.2  
Oracle Streams Performance Tuning Best Practices: Oracle Database 10g Release 10.2  
Tools
Oracle Enterprise Manager Grid Control (Recommended Release 10.2.0.5)
Streams Health Check Utility
Streams Monitor (STRMMON)
SQL Scripts Included in Oracle Streams Administrators Guide
Training
Oracle Database 10g: Implement Streams 
Books
Oracle Streams: A Practical Guide for Data Replication & Information Sharing by Kirtikumar Deshpande
Oracle Database 10g High Availability with RAC, Flashback, and Data Guard by Mathew Hart, Scott Jesse
Oracle Streams: High Speed Replication and Data Sharing by Madhu Tumma 


====================================================
Streams patches
====================================================
1. 7937113 10.2.0.4 Data Guard Bundled Patch for Logical Standby/Streams
2. 7599054 MERGE LABEL REQUEST ON TOP OF 10.2.0.4 FOR BUGS 4966512,7207654, 6134664, 6600051 6915767 6200820
3. 6838714 APPLY PROCESS IS SLOW AFTER UPGRADING TO 10.2.0.3
4. 6827260 EXCESSIVE MEMORY USAGE FOR LCR CACHE DUE TO LARGE FREELISTS
5. 6640411 AFTER CHANGE QUEUE_TO_QUEUE=>TRUE, PROPAGATION DOES NOT WORK
6. 5933656 PROPAGATION ORA-600 [KWQPCBK179], [1], [1369]
==============================================================
Parameters for Source
==============================================================
Parameter	Value
timed_statistics	TRUE
shared_pool_size	167772160 (existing value)
streams_pool_size	268435456 (current value)
Compatible	10.2.0.3.0 (existing value)
log_archive_config	'SEND,DG_CONFIG=(dsghdev3,dsgodev1)'
log_archive_dest_2	'SERVICE=DSGODEV1.WORLD LGWR ASYNC NOREGISTER VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=DSGODEV1'
log_archive_dest_state_2	DEFER
db_domain	WORLD
job_queue_processes	10
db_name	DSGHDEV3
statistics_level	TYPICAL
aq_tm_processes	1

==============================================================
Parameters for Target
==============================================================

Parameter	Value
timed_statistics	TRUE
shared_pool_size	419430400
streams_pool_size	268435456
sga_target	2147483648
Compatible	10.2.0.4.0
log_archive_config	'RECEIVE,DG_CONFIG=(dsghdev3,dsgodev1)'
log_archive_dest_2	LOCATION=/data/oracle/DSGODEV1/archive02
log_archive_dest_state_2	Enable
db_domain	WORLD
job_queue_processes	4
db_name	DSGODEV1
statistics_level	TYPICAL
======================================================
To check the apply process
======================================================

set linesize 90
set pagesize 20

column sid_serial format a10
column Apply_name format a28
column role format a14
column os_process format a26


select a.apply_name || ' n' || a.inst_id APPlY_NAME 
, 'coordinator' ROLE
, a.sid || ',' || a.serial# SID_SERIAL 
, REPLACE(p.program, 'oracle@','') || ': ' || p.spid OS_PROCESS
from gv$streams_apply_coordinator a , gv$process p, gv$session s
where s.sid=a.sid and s.serial#=a.serial# and p.ADDR=s.PADDR
and a.inst_id=p.inst_id and a.inst_id=s.inst_id
UNION 
select a.apply_name || ' n' || a.inst_id APPlY_NAME 
, 'server' ROLE
, a.sid || ',' || a.serial# SID_SERIAL 
, REPLACE(p.program, 'oracle@','') || ': ' || p.spid OS_PROCESS
from gv$streams_apply_server a , gv$process p, gv$session s
where s.sid=a.sid and s.serial#=a.serial# and p.ADDR=s.PADDR
and a.inst_id=p.inst_id and a.inst_id=s.inst_id
UNION 
select a.apply_name || ' n' || a.inst_id APPlY_NAME
, 'reader' ROLE
, a.sid || ',' || a.serial# SID_SERIAL
, REPLACE(p.program, 'oracle@','') || ': ' || p.spid OS_PROCESS
from gv$streams_apply_reader a , gv$process p, gv$session s
where s.sid=a.sid and s.serial#=a.serial# and p.ADDR=s.PADDR
and a.inst_id=p.inst_id and a.inst_id=s.inst_id
order by 1,2
/
set linesize 80
======================================================
To check the Capture process
======================================================
set linesize 90

column capture_name format a28
column role format a14
column sid_serial format a10
column os_process format a26

select c.capture_name || ' n' || v.inst_id CAPTURE_NAME
       , 'capture' ROLE
       , v.sid || ',' || v.serial# SID_SERIAL
       , REPLACE(p.program,'oracle@','') || ': ' || p.spid OS_PROCESS
from dba_capture c, gv$streams_capture v, gv$process p, gv$session s
where c.capture_name = v.capture_name 
and   s.sid=v.sid and s.serial#=v.serial# and p.ADDR=s.PADDR 
and   v.inst_id=p.inst_id and v.inst_id=s.inst_id
UNION
select v.capture_name || ' n' || v.inst_id CAPTURE_NAME
       , 'lgmnr ' || l.role
       ,l.sid || ',' || l.serial# SID_SERIAL
       , REPLACE(p.program,'oracle@','') || ': ' || p.spid OS_PROCESS
from gv$logmnr_process l, gv$streams_capture v, gv$process p, gv$session s
where   s.sid=l.sid and s.serial#=l.serial# and p.ADDR=s.PADDR
and   v.logminer_id = l.session_id
and   l.inst_id=p.inst_id and l.inst_id=s.inst_id
and   v.inst_id=p.inst_id and v.inst_id=s.inst_id
and l.role != v.capture_name
order by 1,2 
/
set linesize 80

<end node> 5P9i0s8y19Z
<node>
To Generate Xplan
1
et autotrace traceonly explain

explain plan set statement_id='q1' for select statement;

set linesize 130
set pagesize 0
select * from table(dbms_xplan.display('PLAN_TABLE','q1'));
select * from table(dbms_xplan.DISPLAY_CURSOR('000000044D46CC90'));

q1 -->> Statement -ID

(example)
----------------
EXPLAIN PLAN SET STATEMENT_ID='TSH' FOR
SELECT *
FROM   emp e, dept d
WHERE  e.deptno = d.deptno
AND    e.ename  = 'SMITH';

SET LINESIZE 130
SET PAGESIZE 0
SELECT * 
FROM   TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE','TSH','BASIC'));

============================================================================================
To display the explan plan for the running sql statement can be identified using the method in the below steps.

eg:

Steps:

/*GETTING THE SQL_ID AND CHILD NUMBER USING V$SESSION FOR THE ACTIVE SESSIONS */
/* SQL_ID is unique */

SQL> select sid,username,sql_id,sql_child_number from v$session where username='HR';

       SID USERNAME           SQL_ID	    SQL_CHILD_NUMBER 
---------- ------------------ ------------- ---------------- 
        26 HR                 2nvr6bpy5mgq2            0      


/* GETTING THE SQL_ID AND CHILD NUMBER USING V$SQL FOR THE ACTIVE SESSIONS */

select sql_id,child_number,sql_text from v$sql


/*USING DMBS_XPLAN.DISPLAY_CURSOR PROCEDURE  WITH FORMAT TYPICAL*/

SQL> SELECT * FROM table(DBMS_XPLAN.DISPLAY_CURSOR(('2nvr6bpy5mgq2'),0));

/*PLAN_TABLE_OUTPUT
---------------------------------------------------------------------
SQL_ID  2nvr6bpy5mgq2, child number 0
-------------------------------------

select * from employees where salary>1000

Plan hash value: 1445457117

-------------------------------------------------------------------------------
| Id  | Operation         | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |           |       |       |     3 (100)|          |
|*  1 |  TABLE ACCESS FULL| EMPLOYEES |   107 |  7276 |     3   (0)| 00:00:01 |

PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("SALARY">1000)

<end node> 5P9i0s8y19Z
<node>
Metalink NoteIDs
1
=========================================================================================================
Confirguration of Streams
=========================================================================================================

http://www.oracle.com/technology/oramag/oracle/04-nov/o64streams.html

=========================================================================================================
Doc ID:  Note:259301.1  - Subject:  CRS and 10g Real Application Clusters 
=========================================================================================================
Detailed Overview of Connecting Oracle to MySQL Using DG4ODBC Database Link [ID 1320645.1]
=========================================================================================================
--------------------------- Begin Shell Script -------------------------------

#!/usr/bin/ksh
#
# Sample 10g CRS resource status query script
#
# Description:
#    - Returns formatted version of crs_stat -t, in tabular
#      format, with the complete rsc names and filtering keywords
#   - The argument, $RSC_KEY, is optional and if passed to the script, will
#     limit the output to HA resources whose names match $RSC_KEY.
# Requirements:
#   - $ORA_CRS_HOME should be set in your environment 

RSC_KEY=$1
QSTAT=-u
AWK=/usr/xpg4/bin/awk    # if not available use /usr/bin/awk

# Table header:echo ""
$AWK \
  'BEGIN {printf "%-45s %-10s %-18s\n", "HA Resource", "Target", "State";
          printf "%-45s %-10s %-18s\n", "-----------", "------", "-----";}'

# Table body:
$ORA_CRS_HOME/bin/crs_stat $QSTAT | $AWK \
 'BEGIN { FS="="; state = 0; }
  $1~/NAME/ && $2~/'$RSC_KEY'/ {appname = $2; state=1};
  state == 0 {next;}
  $1~/TARGET/ && state == 1 {apptarget = $2; state=2;}
  $1~/STATE/ && state == 2 {appstate = $2; state=3;}
  state == 3 {printf "%-45s %-10s %-18s\n", appname, apptarget, appstate; state=0;}'

--------------------------- End Shell Script -------------------------------

Doc ID:  Note:556453.1 - Subject:  HOW TO MAKE RAC DATABASE SERVICES STARTUP AUTOMATICALLY, AFTER A NORMAL DATABASE SHUTDOWN 


Doc ID:  Note:215187.1  - SQLTXPLAIN.SQL - Enhanced Explain Plan and related diagnostic info for one SQL statement


How To Move SQL Profiles From One Database To Another Database [ID 457531.1]
=========================================================================================================
Upgrade  Note:316889.1
Complete Checklist for Manual Upgrades to 11gR2 [ID 837570.1]
=========================================================================================================

Metalink Articles
259301.1 - CRS & 10G RAC 
264847.1 - How to configure VIPS for 10G RAC 
240001.1 - Troubleshooting CRS root.sh issues 
239998.1 - How to clean up after a failed CRS install 
264699.1 - CSS fails to flush on OCFS 
250906.1 - 10G CRS Install and troubleshooting 
BUG 3467544 - CRS Fails on write to Voting file on OCFS 
243304.1 - 10g : Transportable Tablespaces Across Different Platforms

http://download.oracle.com/docs/cd/B19306_01/install.102/b14205/whatsnew.htm#sthref18

http://youngcow.net/doc/oracle10g/
==========================================================================================================
230672.1 - RMAN Clone on ASM DB
==========================================================================================================
276434.1 : Modifying the VIP or VIP Hostname of a 10g or 11g Oracle Clusterware Node 

283684.1  : How to Change Interconnect/Public Interface IP or Subnet in Oracle Clusterware 


SQL> oradebug SETMYPID
Statement processed.
SQL> oradebug IPC
Information written to trace file.
SQL> oradebug TRACEFILE_NAME
/app/oracle/PNYESC40/admin/udump/pnyesc42_ora_31259.trc

oinstall@nyl06d-0002b:/app/oracle/CRS/log/nyl06d-0002b/cssd> cat /app/oracle/PNYESC40/admin/udump/pnyesc42_ora_31259.trc

SKGXPT 0x67fe830 flags SSKGXPT_READPENDING     socket no 7     IP 169.39.33.222        UDP 27232
context timestamp 0
        no ports

Looking further:

Defined:
oinstall@nyl06d-0002b:/app/oracle/CRS/bin> ./oifcfg getif
eth1  10.1.1.11  global  cluster_interconnect
eth0  169.39.33.221  global  public
Available:
oinstall@nyl06d-0002b:/app/oracle/CRS/bin> ./oifcfg iflist
eth0  169.39.33.128
eth1  10.1.1.0
veth31  192.168.255.0

Defined:
$ nyl06d-0002a:PNYESC41:/app/oracle/CRS/bin >./oifcfg getif
eth1  10.1.1.11  global  cluster_interconnect
eth0  169.39.33.221  global  public
Available:
$ nyl06d-0002a:PNYESC41:/app/oracle/CRS/bin >./oifcfg iflist
eth0  169.39.33.128
eth1  10.1.1.0
veth31  192.168.255.0

==============================================================================================================
http://download.oracle.com/docs/cd/B19306_01/backup.102/b14192/strategy003.htm
==============================================================================================================

Doc ID:  378234.1 - Rman Catalog Resync Operation is Very slow at 10G
==============================================================================================================

Rman backup retention policy [ID 462978.1
==============================================================================================================
Changing the NLS_CHARACTERSET to AL32UTF8 / UTF8 (Unicode) [ID 260192.1]

==============================================================================================================
SCRIPT: Changing columns to CHAR length semantics ( NLS_LENGTH_SEMANTICS ) [ID 313175.1]
https://support.oracle.com/CSP/main/article?cmd=show&id=313175.1&type=NOT

==============================================================================================================
ORA-01410: Invalid Rowid When Using rowid Generated from V$Session and Dba_objects [ID 603661.1] 
==============================================================================================================
Upgrading Database Version Online Using Streams and RMAN (Doc ID 782444.1)
http://docs.oracle.com/cd/B28359_01/server.111/b28321/ap_strup.htm
==============================================================================================================
RDA 4 - Health Check / Validation Engine Guide [ID 250262.1]
==============================================================================================================
Ora-02069 When Using a Local Function While Updating a Remote Table [ID 342320.1]
==============================================================================================================

<end node> 5P9i0s8y19Z
<node>
Sybase
1
For LN
========================================================================
isql -Uu_selvam -S PLNITEDOM05 -w1023
use servers
go
select * from heartbeats where host_name like '%pns08d-0001%'
go

isql -Uu_selvam -S PLNITEDOM04 -w1024
Password:
use p_dbmon001
go

isql -Uu_selvam -S PNYCSDBA03 -w1023


========================================================================
For NY
========================================================================
isql -Uu_selvam -S PNYCSDBA03  -w1023
use p_dbmon001 
go
select * from heartbeats where host_name like '%pnl06d-6202b%'
go

========================================================================
ftpaccount
========================================================================
dbmsftp
inc7uded

========================================================================
To start SPy Manually
========================================================================

/app/dbatools/DBE_DBATOOLS/Release_Version/bin/spy.scr -H sol06d-0108b.eu.hedani.net -S PLNPCS52 -t ora_standards

<end node> 5P9i0s8y19Z
<node>
ASMcmds
1
/etc/init.d/oracleasm status PNYB2H40_DATA1
/etc/init.d/oracleasm querydisk PNYB2H40_DATA1

njl15d-4401:/app/bcv/PNYB2H40/bin # /etc/init.d/oracleasm listdisks


ls -ltr | awk '/PNYCIS01/ { print "rcp nys01d-5101c:/app/oracle/PNYCIS01/admin/rman/" $9 " /app/oracle/PNYCIS01/admin/rman/ &" }'

<end node> 5P9i0s8y19Z
<node>
AWR related queries
1
To find the interval and retentation
==========================================================================================================================================
select
      extract( day from snap_interval) *24*60+
      extract( hour from snap_interval) *60+
      extract( minute from snap_interval ) "Snapshot Interval Mins",
      ((extract( day from retention) *24*60+
      extract( hour from retention) *60+
      extract( minute from retention ))/60)/24 "Retention Interval in Days"
from dba_hist_wr_control;



==========================================================================================================================================
To modify the retention and snap interval
==========================================================================================================================================


execute dbms_workload_repository.modify_snapshot_settings (   interval => 60,    retention => 1576800);

Oracle has published suggested storage requirements for AWR based on the activity and complexity of your 10g database:

  Active Sessions number of
CPU's (num_cpus) number of 
schema objects Monthly
space required (gig) 
Small 10 2 500 2 
Medium 20 8 5,000 8 
Large 100 32 50,000 20 

Here, we choose out approximate database size and see estimated space for the AWR dba_hist tables.  Oracle provides the SYSAUX sizing utility called utlsyxsz.sql (in $ORACLE_HOME/rdbms/admin) for estimating your AWR retention based on disk space consumption.

<end node> 5P9i0s8y19Z
<node>
Bind variable peeking
1
================================================================================================================================================
To find out why the sql cursor was not shared 
================================================================================================================================================
 
select * from v$sql_shared_cursor where sql_id = '<sql_id>'

SELECT * FROM V$SQL_BIND_CAPTURE WHERE was_captured='YES' AND sql_id =  'bugjv2vytumxd'


================================================================================================================================================
To verify if bind peeking is taking place for a statement
================================================================================================================================================

 select  substr(column_value,instr(column_value,'"',1)+1,instr(column_value,'"',1,2) - instr(column_value,'"',1,1)-1) bind_name
 , extractvalue(value(d),'/bind' )
      from
      xmltable('/other_xml/peeked_binds/bind'
       passing (  select   xmltype(other_xml) as xmlval
       from
       v$sql_plan
       where  other_xml is not null and sql_id = 'bugjv2vytumxd'
        and child_number = 0
       and other_xml like '%peeked%' )d)
     ) d
 

================================================================================================================================================
To get the bind values used during the parsing phase....
================================================================================================================================================

select sql_id,sbm.address,child_number,sbm.position,bind_name
,dbms_sqltune.extract_bind(sql.bind_data,sbm.position).value_string value_string
,dbms_sqltune.extract_bind(sql.bind_data,sbm.position).datatype_string  datatype
,dbms_sqltune.extract_bind(sql.bind_data,sbm.position).last_captured  last_parsed
,dbms_sqltune.extract_bind(sql.bind_data,sbm.position).precision precision
,dbms_sqltune.extract_bind(sql.bind_data,sbm.position).scale scale
,dbms_sqltune.extract_bind(sql.bind_data,sbm.position).max_length max_length
,nvl2(dbms_sqltune.extract_bind(sql.bind_data,sbm.position), 'YES', 'NO') was_captured
from v$sql_bind_metadata sbm join v$sql sql 
on sbm.address  = sql.child_address
WHERE SQL_ID='bugjv2vytumxd'

================================================================================================================================================
To get the Plan
================================================================================================================================================

select * from table( dbms_xplan.display_cursor('<sql_id>', <child_number> ) ); 

<end node> 5P9i0s8y19Z
<node>
RMAN
1
SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,
       ROUND(SOFAR/TOTALWORK*100,2) "% COMPLETE"
       FROM V$SESSION_LONGOPS
       WHERE OPNAME LIKE 'RMAN%' AND OPNAME NOT LIKE '%aggregate%'
AND TOTALWORK != 0 AND SOFAR <> TOTALWORK;


set linesize 200
col START_TIME format a20
col END_TIME format a20
column STATUS format a15
select SESSION_KEY "KEY" , INPUT_TYPE, STATUS, to_char(START_TIME,'mm/dd/yy hh24:mi') "START_TIME",to_char(END_TIME,'mm/dd/yy hh24:mi') "END_TIME",
round(elapsed_seconds/3600,2) hrs from V$RMAN_BACKUP_JOB_DETAILS order by session_key ;

================================================================================================================
To Get the Lastest Backup pieces
================================================================================================================

select distinct bp.handle
from rc_backup_set bs, rc_backup_piece bp,
  (select max(start_time) start_time from rc_backup_set
  where incremental_level = 0) max_ex,
  (select min(start_time) start_time from rc_backup_set
   where CONTROLFILE_INCLUDED = 'BACKUP' and start_time >
 (select max(start_time) start_time from rc_backup_set
  where incremental_level = 0) ) max_bs
where bs.start_time > (select max(start_time) from
  (select sysdate-999 start_time from dual union select
   start_time from rc_backup_set where CONTROLFILE_INCLUDED = 'BACKUP') ctrl
  where ctrl.start_time < max_ex.start_time)
and bs.start_time <= max_bs.start_time
and bs.start_time > to_date('01-FEB-2007 04:00','DD-MON-YYYY HH24:MI')
and bs.set_stamp = bp.set_stamp

================================================================================================================
To Get the max SCN from catalog
================================================================================================================

select min(next_chng) from
    (
    select thread#, max(next_change#) next_chng from rc_backup_archivelog_details
    where btype = 'BACKUPSET' and btype_key in
    (
     select distinct bs.bs_key
     from rc_backup_set bs, rc_backup_piece bp,
     (
      select max(start_time) start_time from rc_backup_set
      where incremental_level = 0
     ) max_ex,
     (
      select min(start_time) start_time from rc_backup_set
      where CONTROLFILE_INCLUDED = 'BACKUP' and start_time >
      (
       select max(start_time) start_time from rc_backup_set
       where incremental_level = 0
      )
     ) max_bs
    where bs.start_time >
         (
          select max(start_time) from
          (
           select sysdate-999 start_time from dual
           union
           select
           start_time from rc_backup_set where CONTROLFILE_INCLUDED = 'BACKUP'
          ) ctrl
          where ctrl.start_time < max_ex.start_time
         )
    and bs.start_time <= max_bs.start_time
    and bs.set_stamp = bp.set_stamp
    )
    group by thread#
)

================================================================================================================

./bplist -C pns15d-4407 -S bkppdc100 -t 4 -R -l -s 04/16/2010 00:00:00 /

<end node> 5P9i0s8y19Z
<node>
Parallel process
1
col username for a12
col "QC SID" for A6
col SID for 99999999
col "QC/Slave" for A8
col "Requested DOP" for 9999
col "Actual DOP" for 9999
col "Slaveset" for A8
col "Slave INST" for A9
col "QC INST" for A6
set pages 300
set lines 200
select
decode(px.qcinst_id,NULL,username,
' - '||lower(substr(pp.SERVER_NAME,
length(pp.SERVER_NAME)-4,4) ) )"Username",
decode(px.qcinst_id,NULL, 'QC', '(Slave)') "QC/Slave" ,
to_char( px.server_set) "SlaveSet",
to_char(s.sid) "SID",
to_char(px.inst_id) "Slave INST",
decode(px.qcinst_id, NULL ,to_char(s.sid) ,px.qcsid) "QC SID",
to_char(px.qcinst_id) "QC INST",
px.req_degree "Req. DOP",
px.degree "Actual DOP"
from gv$px_session px,
gv$session s ,
gv$px_process pp
where px.sid=s.sid (+)
and px.serial#=s.serial#(+)
and px.inst_id = s.inst_id(+)
and px.sid = pp.sid (+)
and px.serial#=pp.serial#(+)
order by 6 , 1 desc
/

<end node> 5P9i0s8y19Z
<node>
VCS
1

bash-3.00# hares -disp ogb_alert_PLNHPRD1 | grep Type
ogb_alert_PLNHPRD1 Type             global       Application


bash-3.00# hatype -display Application -attribute RestartLimit
#Type        Attribute              Value
Application  RestartLimit           0

<end node> 5P9i0s8y19Z
<node>
Performance
1
2)Physica reads high ,due to full scan, how to avoid this
Ans-Yes, fu scna can lead to increse inphysical read.Ensure you have made the indexex selective by
a)optimizer_index_caching=30
optimizer_index_cost_adj=60
and stats are always fresh

3)Try using the baselines or outines for such frequently changing performances.
If the query performance changes with same plan, it only indicates there is change in data or stats or environment including optimizer parameters.
So you need to ensure that every time any of these changes you regather the stats and provide right inputs to optimizer

<end node> 5P9i0s8y19Z
<node>
dbv
1
once ran dbv

select dbms_utility.data_block_address_file(54528484) from dual;

select dbms_utility.data_block_address_block(54528484) from dual;

<end node> 5P9i0s8y19Z
<node>
Achive
1
We build a new backup statergy to have recoverable QA environment not to depend on production data always

<end node> 5P9i0s8y19Z
<node>
Functions
1
To fetch the LONG column in the where clause
=============================================
create or replace
function getlong1( p_viewname in varchar2, p_owner in varchar2)
return number
  is
          l_data long;
  begin
         select text into l_data from dba_views where view_name = p_viewname and owner=p_owner;
          return instr( upper(l_data), 'PLL');
          --return upper(substr( l_data, 1, 25000 ));
  end;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
select owner,view_name,text from
dba_views where getlong1(view_name,owner)>0      order by owner;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<end node> 5P9i0s8y19Z
<node>
DDL Queries
1
DBLINK creation
===============
SELECT 'create '||DECODE(U.NAME,'PUBLIC','public ')||'database link '||CHR(10)
 ||DECODE(U.NAME,'PUBLIC',Null, U.NAME||'.')|| L.NAME||chr(10)
 ||'connect to ' || L.USERID || ' identified by '
 ||L.PASSWORD||' using ''' || L.host || ''''
 ||chr(10)||';' TEXT
 FROM sys.link$ L, sys.user$ U
 WHERE L.OWNER# = U.USER#;

<end node> 5P9i0s8y19Z
<node>
FlashBack
1
COLUMN versions_startscn FORMAT 99999999999999999
COLUMN versions_starttime FORMAT A24
COLUMN versions_endscn FORMAT 99999999999999999
COLUMN versions_endtime FORMAT A24
COLUMN versions_xid FORMAT A16
COLUMN versions_operation FORMAT A1
COLUMN description FORMAT A11
SET LINESIZE 200

SELECT versions_startscn, versions_starttime, 
       versions_endscn, versions_endtime,
       versions_xid, versions_operation,
       PERMISSION_ID
FROM   RTS.SSO_GROUP_PERMISSION 
       VERSIONS BETWEEN TIMESTAMP TO_TIMESTAMP('2013-01-10 20:00:00', 'YYYY-MM-DD HH24:MI:SS')
       AND TO_TIMESTAMP('2013-01-10 21:00:00', 'YYYY-MM-DD HH24:MI:SS')
WHERE  GROUP_ID= 'PM';
===================================================================================================================
Flashback Query
===================================================================================================================
Flashback Query allows the contents of a table to be queried with reference to a specific point in time, using the AS OF clause. Essentially it is the same as the DBMS_FLASHBACK functionality or Oracle 9i, but in a more convenient form. For example.
===================================================================================================================
CREATE TABLE flashback_query_test (
  id  NUMBER(10)
);

SELECT current_scn, TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') FROM v$database;

CURRENT_SCN TO_CHAR(SYSTIMESTAM
----------- -------------------
     722452 2004-03-29 13:34:12

INSERT INTO flashback_query_test (id) VALUES (1);
COMMIT;

SELECT COUNT(*) FROM flashback_query_test;

  COUNT(*)
----------
         1

SELECT COUNT(*) FROM flashback_query_test AS OF TIMESTAMP TO_TIMESTAMP('2004-03-29 13:34:12', 'YYYY-MM-DD HH24:MI:SS');

  COUNT(*)
----------
         0

SELECT COUNT(*) FROM flashback_query_test AS OF SCN 722452;

  COUNT(*)
----------
         0
===================================================================================================================
Flashback Version Query
===================================================================================================================
Flashback version query allows the versions of a specific row to be tracked during a specified time period using the VERSIONS BETWEEN clause.
===================================================================================================================
CREATE TABLE flashback_version_query_test (
  id           NUMBER(10),
  description  VARCHAR2(50)
);

INSERT INTO flashback_version_query_test (id, description) VALUES (1, 'ONE');
COMMIT;

SELECT current_scn, TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') FROM v$database;

CURRENT_SCN TO_CHAR(SYSTIMESTAM
----------- -------------------
     725202 2004-03-29 14:59:08
     
UPDATE flashback_version_query_test SET description = 'TWO' WHERE id = 1;
COMMIT;
UPDATE flashback_version_query_test SET description = 'THREE' WHERE id = 1;
COMMIT;

SELECT current_scn, TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') FROM v$database;

CURRENT_SCN TO_CHAR(SYSTIMESTAM
----------- -------------------
     725219 2004-03-29 14:59:36
     
COLUMN versions_startscn FORMAT 99999999999999999
COLUMN versions_starttime FORMAT A24
COLUMN versions_endscn FORMAT 99999999999999999
COLUMN versions_endtime FORMAT A24
COLUMN versions_xid FORMAT A16
COLUMN versions_operation FORMAT A1
COLUMN description FORMAT A11
SET LINESIZE 200

SELECT versions_startscn, versions_starttime, 
       versions_endscn, versions_endtime,
       versions_xid, versions_operation,
       description  
FROM   flashback_version_query_test 
       VERSIONS BETWEEN TIMESTAMP TO_TIMESTAMP('2004-03-29 14:59:08', 'YYYY-MM-DD HH24:MI:SS')
       AND TO_TIMESTAMP('2004-03-29 14:59:36', 'YYYY-MM-DD HH24:MI:SS')
WHERE  id = 1;

 VERSIONS_STARTSCN VERSIONS_STARTTIME          VERSIONS_ENDSCN VERSIONS_ENDTIME         VERSIONS_XID     V DESCRIPTION
------------------ ------------------------ ------------------ ------------------------ ---------------- - -----------
            725212 29-MAR-04 02.59.16 PM                                                02001C0043030000 U THREE
            725209 29-MAR-04 02.59.16 PM                725212 29-MAR-04 02.59.16 PM    0600030021000000 U TWO
                                                        725209 29-MAR-04 02.59.16 PM                       ONE
SELECT versions_startscn, versions_starttime, 
       versions_endscn, versions_endtime,
       versions_xid, versions_operation,
       description  
FROM   flashback_version_query_test 
       VERSIONS BETWEEN SCN 725202 AND 725219
WHERE  id = 1;


 VERSIONS_STARTSCN VERSIONS_STARTTIME          VERSIONS_ENDSCN VERSIONS_ENDTIME         VERSIONS_XID     V DESCRIPTION
------------------ ------------------------ ------------------ ------------------------ ---------------- - -----------
            725212 29-MAR-04 02.59.16 PM                                                02001C0043030000 U THREE
            725209 29-MAR-04 02.59.16 PM                725212 29-MAR-04 02.59.16 PM    0600030021000000 U TWO
                                                        725209 29-MAR-04 02.59.16 PM                       ONE
===================================================================================================================
The available pseudocolumn meanings are:
VERSIONS_STARTSCN or VERSIONS_STARTTIME - Starting SCN and TIMESTAMP when row took on this value. The value of NULL is returned if the row was created before the lower bound SCN ot TIMESTAMP.
VERSIONS_ENDSCN or VERSIONS_ENDTIME - Ending SCN and TIMESTAMP when row last contained this value. The value of NULL is returned if the value of the row is still current at the upper bound SCN ot TIMESTAMP.
VERSIONS_XID - ID of the transaction that created the row in it's current state.
VERSIONS_OPERATION - Operation performed by the transaction ((I)nsert, (U)pdate or (D)elete)
===================================================================================================================
Flashback Transaction Query
===================================================================================================================
Flashback transaction query can be used to get extra information about the transactions listed by flashback version queries. The VERSIONS_XID column values from a flashback version query can be used to query the FLASHBACK_TRANSACTION_QUERY view.

SELECT xid, operation, start_scn,commit_scn, logon_user, undo_sql
FROM   flashback_transaction_query
WHERE  xid = HEXTORAW('0600030021000000');


XID              OPERATION                         START_SCN COMMIT_SCN
---------------- -------------------------------- ---------- ----------
LOGON_USER
------------------------------
UNDO_SQL
----------------------------------------------------------------------------------------------------
0600030021000000 UPDATE                               725208     725209
SCOTT
update "SCOTT"."FLASHBACK_VERSION_QUERY_TEST" set "DESCRIPTION" = 'ONE' where ROWID = 'AAAMP9AAEAAAA
AYAAA';

0600030021000000 BEGIN                                725208     725209
SCOTT

XID              OPERATION                         START_SCN COMMIT_SCN
---------------- -------------------------------- ---------- ----------
LOGON_USER
------------------------------
UNDO_SQL
----------------------------------------------------------------------------------------------------



2 rows selected.
===================================================================================================================
Flashback Table
===================================================================================================================
The FLASHBACK TABLE command allows point in time recovery of individual tables subject to the following requirements.
You must have either the FLASHBACK ANY TABLE system privilege or have FLASHBACK object privilege on the table.
You must have SELECT, INSERT, DELETE, and ALTER privileges on the table.
There must be enough information in the undo tablespace to complete the operation.
Row movement must be enabled on the table (ALTER TABLE tablename ENABLE ROW MOVEMENT;).
=================================================================================================================== 
The following example creates a table, inserts some data and flashbacks to a point prior to the data insertion. Finally it flashbacks to the time after the data insertion.
===================================================================================================================
CREATE TABLE flashback_table_test (
  id  NUMBER(10)
);

ALTER TABLE flashback_table_test ENABLE ROW MOVEMENT;

SELECT current_scn FROM v$database;

CURRENT_SCN
-----------
     715315

INSERT INTO flashback_table_test (id) VALUES (1);
COMMIT;

SELECT current_scn FROM v$database;

CURRENT_SCN
-----------
     715340

FLASHBACK TABLE flashback_table_test TO SCN 715315;

SELECT COUNT(*) FROM flashback_table_test;

  COUNT(*)
----------
         0

FLASHBACK TABLE flashback_table_test TO SCN 715340;

SELECT COUNT(*) FROM flashback_table_test;

  COUNT(*)
----------
         1
===================================================================================================================
Flashback of tables can also be performed using timestamps.
===================================================================================================================
FLASHBACK TABLE flashback_table_test TO TIMESTAMP TO_TIMESTAMP('2004-03-03 10:00:00', 'YYYY-MM-DD HH:MI:SS');
Flashback Drop (Recycle Bin)

In Oracle 10g the default action of a DROP TABLE command is to move the table to the recycle bin (or rename it), rather than actually dropping it. The DROP TABLE ... PURGE option can be used to permanently drop a table.

DROP TABLE my_table PURGE;
The recycle bin is a logical collection of previously dropped objects, with access tied to the DROP privilege. This feature does not use flashback logs or undo, so it is independent of the other flashback technologies. The contents of the recycle bin can be shown using the SHOW RECYCLEBIN command and purged using the PURGE TABLE command. As a result, a previously dropped table can be recovered from the recycle bin.

CREATE TABLE flashback_drop_test (
  id  NUMBER(10)
);

INSERT INTO flashback_drop_test (id) VALUES (1);
COMMIT;

DROP TABLE flashback_drop_test;

SHOW RECYCLEBIN

ORIGINAL NAME    RECYCLEBIN NAME                OBJECT TYPE  DROP TIME
---------------- ------------------------------ ------------ -------------------
FLASHBACK_DROP_T BIN$TstgCMiwQA66fl5FFDTBgA==$0 TABLE        2004-03-29:11:09:07
EST

FLASHBACK TABLE flashback_drop_test TO BEFORE DROP;

SELECT * FROM flashback_drop_test;

        ID
----------
         1
Tables in the recycle bin can be queried like any other table.

DROP TABLE flashback_drop_test;

SHOW RECYCLEBIN

ORIGINAL NAME    RECYCLEBIN NAME                OBJECT TYPE  DROP TIME
---------------- ------------------------------ ------------ -------------------
FLASHBACK_DROP_T BIN$TDGqmJZKR8u+Hrc6PGD8kw==$0 TABLE        2004-03-29:11:18:39
EST

SELECT * FROM "BIN$TDGqmJZKR8u+Hrc6PGD8kw==$0";

        ID
----------
         1
===================================================================================================================
If an object is dropped and recreated multiple times all dropped versions will be kept in the recycle bin, subject to space. Where multiple versions are present it's best to reference the tables via the RECYCLEBIN_NAME. For any references to the ORIGINAL_NAME it is assumed the most recent object is drop version in the referenced question. During the flashback operation the table can be renamed.
===================================================================================================================
FLASHBACK TABLE flashback_drop_test TO BEFORE DROP RENAME TO flashback_drop_test_old;
Several purge options exist.
===================================================================================================================
PURGE TABLE tablename;                   -- Specific table.
PURGE INDEX indexname;                   -- Specific index.
PURGE TABLESPACE ts_name;                -- All tables in a specific tablespace.
PURGE TABLESPACE ts_name USER username;  -- All tables in a specific tablespace for a specific user.
PURGE RECYCLEBIN;                        -- The current users entire recycle bin.
PURGE DBA_RECYCLEBIN;                    -- The whole recycle bin.
Several restrictions apply relating to the recycle bin.
Only available for non-system, locally managed tablespaces.
There is no fixed size for the recycle bin. The time an object remains in the recycle bin can vary.
The objects in the recycle bin are restricted to query operations only (no DDL or DML).
Flashback query operations must reference the recycle bin name.
Tables and all dependent objects are placed into, recovered and purged from the recycle bin at the same time.
Tables with Fine Grained Access policies aer not protected by the recycle bin.
Partitioned index-organized tables are not protected by the recycle bin.
The recycle bin does not preserve referential integrity.
 ===================================================================================================================
This feature can be disabled/enabled at the session or system level.
===================================================================================================================
-- Session level.
ALTER SESSION SET recyclebin = OFF;
ALTER SESSION SET recyclebin = ON;

-- System level.
ALTER SYSTEM SET recyclebin = OFF;
ALTER SYSTEM SET recyclebin = ON;
Flashback Database

The FLASHBACK DATABASE command is a fast alternative to performing an incomplete recovery. In order to flashback the database you must have SYSDBA privilege and the flash recovery area must have been prepared in advance.

The FLASHBACK_ON column of the V$DATABASE view shows the current status of flashback database.

If the database is in NOARCHIVELOG it must be switched to ARCHIVELOG mode.

CONN / AS SYSDBA
ALTER SYSTEM SET log_archive_dest_1='location=d:\oracle\oradata\DB10G\archive\' SCOPE=SPFILE;
ALTER SYSTEM SET log_archive_format='ARC%S_%R.%T' SCOPE=SPFILE;
SHUTDOWN IMMEDIATE
STARTUP MOUNT
ALTER DATABASE ARCHIVELOG;
ALTER DATABASE OPEN;
Flashback must be enabled before any flashback operations are performed.

CONN / AS SYSDBA
SHUTDOWN IMMEDIATE
STARTUP MOUNT EXCLUSIVE
ALTER DATABASE FLASHBACK ON;
ALTER DATABASE OPEN;
With flashback enabled the database can be switched back to a previous point in time or SCN without the need for a manual incomplete recovery. In the following example a table is created, the database is then flashbacked to a time before the table was created.

-- Create a dummy table.
CONN scott/tiger
CREATE TABLE flashback_database_test (
  id  NUMBER(10)
);

-- Flashback 5 minutes.
CONN / AS SYSDBA
SHUTDOWN IMMEDIATE
STARTUP MOUNT EXCLUSIVE
FLASHBACK DATABASE TO TIMESTAMP SYSDATE-(1/24/12);
ALTER DATABASE OPEN RESETLOGS;

-- Check that the table is gone.
CONN scott/tiger
DESC flashback_database_test
Some other variations of the flashback database command include.

FLASHBACK DATABASE TO TIMESTAMP my_date;
FLASHBACK DATABASE TO BEFORE TIMESTAMP my_date;
FLASHBACK DATABASE TO SCN my_scn;
FLASHBACK DATABASE TO BEFORE SCN my_scn;
===================================================================================================================
The window of time that is available for flashback is determined by the DB_FLASHBACK_RETENTION_TARGET parameter. The maximum flashback can be determined by querying the V$FLASHBACK_DATABASE_LOG view. It is only possible to flashback to a point in time after flashback was enabled on the database and since the last RESETLOGS command.
===================================================================================================================
In addition to using SCNs and timestamps, we can create guaranteed restore points.
===================================================================================================================
CREATE RESTORE POINT before_changes;
Existing restore points can be displayed using the V$RESTORE_POINT view. To flashback to this restore point, we would ssue the following command.

FLASHBACK DATABASE TO RESTORE POINT before_changes;
Flashback Query Functions

The TIMESTAMP_TO_SCN and SCN_TO_TIMESTAMP functions have been added to SQL and PL/SQL to simplify flashback operations.

SELECT *
FROM   emp AS OF SCN TIMESTAMP_TO_SCN(SYSTIMESTAMP - 1/24);

SELECT *
FROM   emp AS OF TIMESTAMP SCN_TO_TIMESTAMP(993240);

DECLARE
  l_scn        NUMBER;
  l_timestamp  TIMESTAMP;
BEGIN
  l_scn       := TIMESTAMP_TO_SCN(SYSTIMESTAMP - 1/24);
  l_timestamp := SCN_TO_TIMESTAMP(l_scn);
END;
/
===================================================================================================================

<end node> 5P9i0s8y19Z
